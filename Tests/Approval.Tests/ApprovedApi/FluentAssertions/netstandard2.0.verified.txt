[assembly: System.Reflection.AssemblyMetadata("RepositoryUrl", "https://github.com/fluentassertions/fluentassertions")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(@"Benchmarks, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d25ff515c85b13ba08f61d466cff5d80a7f28ba197bbf8796085213e7a3406f970d2a4874932fed35db546e89af2da88c194bf1b7f7ac70de7988c78406f7629c547283061282a825616eb7eb48a9514a7570942936020a9bb37dca9ff60b778309900851575614491c6d25018fadb75828f4c7a17bf2d7dc86e7b6eafc5d8f")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(@"FluentAssertions.Equivalency.Specs, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d25ff515c85b13ba08f61d466cff5d80a7f28ba197bbf8796085213e7a3406f970d2a4874932fed35db546e89af2da88c194bf1b7f7ac70de7988c78406f7629c547283061282a825616eb7eb48a9514a7570942936020a9bb37dca9ff60b778309900851575614491c6d25018fadb75828f4c7a17bf2d7dc86e7b6eafc5d8f")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(@"FluentAssertions.Specs, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d25ff515c85b13ba08f61d466cff5d80a7f28ba197bbf8796085213e7a3406f970d2a4874932fed35db546e89af2da88c194bf1b7f7ac70de7988c78406f7629c547283061282a825616eb7eb48a9514a7570942936020a9bb37dca9ff60b778309900851575614491c6d25018fadb75828f4c7a17bf2d7dc86e7b6eafc5d8f")]
namespace FluentAssertions
{
    public class AggregateExceptionExtractor : FluentAssertions.Specialized.IExtractExceptions
    {
        public AggregateExceptionExtractor() { }
        public System.Collections.Generic.IEnumerable<T> OfType<T>(System.Exception actualException)
            where T : System.Exception { }
    }
    public class AndConstraint<TParent>
    {
        public AndConstraint(TParent parent) { }
        public TParent And { get; }
    }
    public class AndWhichConstraint<TParent, TSubject> : FluentAssertions.AndConstraint<TParent>
    {
        public AndWhichConstraint(TParent parent, System.Collections.Generic.IEnumerable<TSubject> subjects) { }
        public AndWhichConstraint(TParent parent, TSubject subject) { }
        public AndWhichConstraint(TParent parent, System.Collections.Generic.IEnumerable<TSubject> subjects, FluentAssertions.Execution.AssertionChain assertionChain) { }
        public AndWhichConstraint(TParent parent, System.Collections.Generic.IEnumerable<TSubject> subjects, FluentAssertions.Execution.AssertionChain assertionChain, string pathPostfix) { }
        public AndWhichConstraint(TParent parent, TSubject subject, FluentAssertions.Execution.AssertionChain assertionChain, string pathPostfix = "") { }
        public TSubject Subject { get; }
        public TSubject Which { get; }
    }
    public static class AssertionConfiguration
    {
        public static FluentAssertions.Configuration.GlobalConfiguration Current { get; }
    }
    public static class AssertionEngine
    {
        public static FluentAssertions.Configuration.GlobalConfiguration Configuration { get; }
        public static FluentAssertions.Execution.ITestFramework TestFramework { get; set; }
        public static void ResetToDefaults() { }
    }
    public static class AssertionExtensions
    {
        public static TTo As<TTo>(this object subject) { }
        public static System.Func<System.Threading.Tasks.Task> Awaiting<T>(this T subject, System.Func<T, System.Threading.Tasks.Task> action) { }
        public static System.Func<System.Threading.Tasks.Task> Awaiting<T>(this T subject, System.Func<T, System.Threading.Tasks.ValueTask> action) { }
        public static System.Func<System.Threading.Tasks.Task<TResult>> Awaiting<T, TResult>(this T subject, System.Func<T, System.Threading.Tasks.Task<TResult>> action) { }
        public static System.Func<System.Threading.Tasks.Task<TResult>> Awaiting<T, TResult>(this T subject, System.Func<T, System.Threading.Tasks.ValueTask<TResult>> action) { }
        public static System.Action Enumerating(this System.Func<System.Collections.IEnumerable> enumerable) { }
        public static System.Action Enumerating<T>(this System.Func<System.Collections.Generic.IEnumerable<T>> enumerable) { }
        public static System.Action Enumerating<T, TResult>(this T subject, System.Func<T, System.Collections.Generic.IEnumerable<TResult>> enumerable) { }
        public static FluentAssertions.Specialized.ExecutionTime ExecutionTime(this System.Func<System.Threading.Tasks.Task> action) { }
        public static FluentAssertions.Specialized.ExecutionTime ExecutionTime(this System.Action action, FluentAssertions.Common.StartTimer createTimer = null) { }
        public static FluentAssertions.Specialized.MemberExecutionTime<T> ExecutionTimeOf<T>(this T subject, System.Linq.Expressions.Expression<System.Action<T>> action, FluentAssertions.Common.StartTimer createTimer = null) { }
        public static System.Action Invoking<T>(this T subject, System.Action<T> action) { }
        public static System.Func<TResult> Invoking<T, TResult>(this T subject, System.Func<T, TResult> action) { }
        public static FluentAssertions.Specialized.ExecutionTimeAssertions Should(this FluentAssertions.Specialized.ExecutionTime executionTime) { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should(this FluentAssertions.Specialized.ExecutionTimeAssertions _) { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should(this FluentAssertions.Specialized.TaskCompletionSourceAssertionsBase _) { }
        public static FluentAssertions.Types.MethodInfoSelectorAssertions Should(this FluentAssertions.Types.MethodInfoSelector methodSelector) { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should(this FluentAssertions.Types.MethodInfoSelectorAssertions _) { }
        public static FluentAssertions.Types.PropertyInfoSelectorAssertions Should(this FluentAssertions.Types.PropertyInfoSelector propertyInfoSelector) { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should(this FluentAssertions.Types.PropertyInfoSelectorAssertions _) { }
        public static FluentAssertions.Types.TypeSelectorAssertions Should(this FluentAssertions.Types.TypeSelector typeSelector) { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should(this FluentAssertions.Types.TypeSelectorAssertions _) { }
        public static FluentAssertions.Specialized.ActionAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Action action) { }
        public static FluentAssertions.Collections.StringCollectionAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Collections.Generic.IEnumerable<string> @this) { }
        public static FluentAssertions.Primitives.DateTimeAssertions Should(this System.DateTime actualValue) { }
        public static FluentAssertions.Primitives.NullableDateTimeAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.DateTime? actualValue) { }
        public static FluentAssertions.Primitives.DateTimeOffsetAssertions Should(this System.DateTimeOffset actualValue) { }
        public static FluentAssertions.Primitives.NullableDateTimeOffsetAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.DateTimeOffset? actualValue) { }
        public static FluentAssertions.Specialized.NonGenericAsyncFunctionAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Func<System.Threading.Tasks.Task> action) { }
        public static FluentAssertions.Primitives.GuidAssertions Should(this System.Guid actualValue) { }
        public static FluentAssertions.Primitives.NullableGuidAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Guid? actualValue) { }
        public static FluentAssertions.Streams.BufferedStreamAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.IO.BufferedStream actualValue) { }
        public static FluentAssertions.Streams.StreamAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.IO.Stream actualValue) { }
        public static FluentAssertions.Types.AssemblyAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Reflection.Assembly assembly) { }
        public static FluentAssertions.Types.ConstructorInfoAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Reflection.ConstructorInfo constructorInfo) { }
        public static FluentAssertions.Types.MethodInfoAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Reflection.MethodInfo methodInfo) { }
        public static FluentAssertions.Types.PropertyInfoAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Reflection.PropertyInfo propertyInfo) { }
        public static FluentAssertions.Primitives.SimpleTimeSpanAssertions Should(this System.TimeSpan actualValue) { }
        public static FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.TimeSpan? actualValue) { }
        public static FluentAssertions.Types.TypeAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Type subject) { }
        public static FluentAssertions.Xml.XAttributeAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Xml.Linq.XAttribute actualValue) { }
        public static FluentAssertions.Xml.XDocumentAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Xml.Linq.XDocument actualValue) { }
        public static FluentAssertions.Xml.XElementAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Xml.Linq.XElement actualValue) { }
        public static FluentAssertions.Primitives.BooleanAssertions Should(this bool actualValue) { }
        public static FluentAssertions.Primitives.NullableBooleanAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this bool? actualValue) { }
        public static FluentAssertions.Numeric.NumericAssertions<byte> Should(this byte actualValue) { }
        public static FluentAssertions.Numeric.NullableNumericAssertions<byte> Should([System.Diagnostics.CodeAnalysis.NotNull] this byte? actualValue) { }
        public static FluentAssertions.Numeric.NumericAssertions<decimal> Should(this decimal actualValue) { }
        public static FluentAssertions.Numeric.NullableNumericAssertions<decimal> Should([System.Diagnostics.CodeAnalysis.NotNull] this decimal? actualValue) { }
        public static FluentAssertions.Numeric.NumericAssertions<double> Should(this double actualValue) { }
        public static FluentAssertions.Numeric.NullableNumericAssertions<double> Should([System.Diagnostics.CodeAnalysis.NotNull] this double? actualValue) { }
        public static FluentAssertions.Numeric.NumericAssertions<float> Should(this float actualValue) { }
        public static FluentAssertions.Numeric.NullableNumericAssertions<float> Should([System.Diagnostics.CodeAnalysis.NotNull] this float? actualValue) { }
        public static FluentAssertions.Numeric.NumericAssertions<int> Should(this int actualValue) { }
        public static FluentAssertions.Numeric.NullableNumericAssertions<int> Should([System.Diagnostics.CodeAnalysis.NotNull] this int? actualValue) { }
        public static FluentAssertions.Numeric.NumericAssertions<long> Should(this long actualValue) { }
        public static FluentAssertions.Numeric.NullableNumericAssertions<long> Should([System.Diagnostics.CodeAnalysis.NotNull] this long? actualValue) { }
        public static FluentAssertions.Primitives.ObjectAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this object actualValue) { }
        public static FluentAssertions.Numeric.NumericAssertions<sbyte> Should(this sbyte actualValue) { }
        public static FluentAssertions.Numeric.NullableNumericAssertions<sbyte> Should([System.Diagnostics.CodeAnalysis.NotNull] this sbyte? actualValue) { }
        public static FluentAssertions.Numeric.NumericAssertions<short> Should(this short actualValue) { }
        public static FluentAssertions.Numeric.NullableNumericAssertions<short> Should([System.Diagnostics.CodeAnalysis.NotNull] this short? actualValue) { }
        public static FluentAssertions.Primitives.StringAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this string actualValue) { }
        public static FluentAssertions.Numeric.NumericAssertions<uint> Should(this uint actualValue) { }
        public static FluentAssertions.Numeric.NullableNumericAssertions<uint> Should([System.Diagnostics.CodeAnalysis.NotNull] this uint? actualValue) { }
        public static FluentAssertions.Numeric.NumericAssertions<ulong> Should(this ulong actualValue) { }
        public static FluentAssertions.Numeric.NullableNumericAssertions<ulong> Should([System.Diagnostics.CodeAnalysis.NotNull] this ulong? actualValue) { }
        public static FluentAssertions.Numeric.NumericAssertions<ushort> Should(this ushort actualValue) { }
        public static FluentAssertions.Numeric.NullableNumericAssertions<ushort> Should([System.Diagnostics.CodeAnalysis.NotNull] this ushort? actualValue) { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TAssertions>(this FluentAssertions.Primitives.BooleanAssertions<TAssertions> _)
            where TAssertions : FluentAssertions.Primitives.BooleanAssertions<TAssertions> { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TAssertions>(this FluentAssertions.Primitives.DateTimeAssertions<TAssertions> _)
            where TAssertions : FluentAssertions.Primitives.DateTimeAssertions<TAssertions> { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TAssertions>(this FluentAssertions.Primitives.DateTimeOffsetAssertions<TAssertions> _)
            where TAssertions : FluentAssertions.Primitives.DateTimeOffsetAssertions<TAssertions> { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TAssertions>(this FluentAssertions.Primitives.DateTimeOffsetRangeAssertions<TAssertions> _)
            where TAssertions : FluentAssertions.Primitives.DateTimeOffsetAssertions<TAssertions> { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TAssertions>(this FluentAssertions.Primitives.DateTimeRangeAssertions<TAssertions> _)
            where TAssertions : FluentAssertions.Primitives.DateTimeAssertions<TAssertions> { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TAssertions>(this FluentAssertions.Primitives.GuidAssertions<TAssertions> _)
            where TAssertions : FluentAssertions.Primitives.GuidAssertions<TAssertions> { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TAssertions>(this FluentAssertions.Primitives.SimpleTimeSpanAssertions<TAssertions> _)
            where TAssertions : FluentAssertions.Primitives.SimpleTimeSpanAssertions<TAssertions> { }
        public static FluentAssertions.Collections.GenericCollectionAssertions<T> Should<T>([System.Diagnostics.CodeAnalysis.NotNull] this System.Collections.Generic.IEnumerable<T> actualValue) { }
        public static FluentAssertions.Specialized.GenericAsyncFunctionAssertions<T> Should<T>([System.Diagnostics.CodeAnalysis.NotNull] this System.Func<System.Threading.Tasks.Task<T>> action) { }
        public static FluentAssertions.Specialized.FunctionAssertions<T> Should<T>([System.Diagnostics.CodeAnalysis.NotNull] this System.Func<T> func) { }
        public static FluentAssertions.Numeric.ComparableTypeAssertions<T> Should<T>([System.Diagnostics.CodeAnalysis.NotNull] this System.IComparable<T> comparableValue) { }
        public static FluentAssertions.Specialized.TaskCompletionSourceAssertions<T> Should<T>(this System.Threading.Tasks.TaskCompletionSource<T> tcs) { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TSubject, TAssertions>(this FluentAssertions.Numeric.NumericAssertionsBase<TSubject, TSubject, TAssertions> _)
            where TSubject :  struct, System.IComparable<TSubject>
            where TAssertions : FluentAssertions.Numeric.NumericAssertions<TSubject, TAssertions> { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TEnum, TAssertions>(this FluentAssertions.Primitives.EnumAssertions<TEnum, TAssertions> _)
            where TEnum :  struct, System.Enum
            where TAssertions : FluentAssertions.Primitives.EnumAssertions<TEnum, TAssertions> { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TSubject, TAssertions>(this FluentAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions> _)
            where TAssertions : FluentAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions> { }
        public static FluentAssertions.Collections.GenericDictionaryAssertions<System.Collections.Generic.IDictionary<TKey, TValue>, TKey, TValue> Should<TKey, TValue>([System.Diagnostics.CodeAnalysis.NotNull] this System.Collections.Generic.IDictionary<TKey, TValue> actualValue) { }
        public static FluentAssertions.Collections.GenericDictionaryAssertions<System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, TKey, TValue> Should<TKey, TValue>([System.Diagnostics.CodeAnalysis.NotNull] this System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> actualValue) { }
        public static FluentAssertions.Collections.GenericDictionaryAssertions<TCollection, TKey, TValue> Should<TCollection, TKey, TValue>([System.Diagnostics.CodeAnalysis.NotNull] this TCollection actualValue)
            where TCollection : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> { }
    }
    public static class AsyncAssertionsExtensions
    {
        public static System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.GenericAsyncFunctionAssertions<T>, T>> WithResult<T>(this System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.GenericAsyncFunctionAssertions<T>, T>> task, T expected, string because = "", params object[] becauseArgs) { }
        public static System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.TaskCompletionSourceAssertions<T>, T>> WithResult<T>(this System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.TaskCompletionSourceAssertions<T>, T>> task, T expected, string because = "", params object[] becauseArgs) { }
    }
    public static class AtLeast
    {
        public static FluentAssertions.OccurrenceConstraint Once() { }
        public static FluentAssertions.OccurrenceConstraint Thrice() { }
        public static FluentAssertions.OccurrenceConstraint Times(int expected) { }
        public static FluentAssertions.OccurrenceConstraint Twice() { }
    }
    public static class AtMost
    {
        public static FluentAssertions.OccurrenceConstraint Once() { }
        public static FluentAssertions.OccurrenceConstraint Thrice() { }
        public static FluentAssertions.OccurrenceConstraint Times(int expected) { }
        public static FluentAssertions.OccurrenceConstraint Twice() { }
    }
    public static class CallerIdentifier
    {
        public static System.Action<string> Logger { get; set; }
        public static string[] DetermineCallerIdentities() { }
        public static string DetermineCallerIdentity() { }
    }
    [System.AttributeUsage(System.AttributeTargets.Method)]
    public class CustomAssertionAttribute : System.Attribute
    {
        public CustomAssertionAttribute() { }
    }
    [System.AttributeUsage(System.AttributeTargets.Assembly)]
    public sealed class CustomAssertionsAssemblyAttribute : System.Attribute
    {
        public CustomAssertionsAssemblyAttribute() { }
    }
    public static class EnumAssertionsExtensions
    {
        public static FluentAssertions.Primitives.EnumAssertions<TEnum> Should<TEnum>(this TEnum @enum)
            where TEnum :  struct, System.Enum { }
        public static FluentAssertions.Primitives.NullableEnumAssertions<TEnum> Should<TEnum>([System.Diagnostics.CodeAnalysis.NotNull] this TEnum? @enum)
            where TEnum :  struct, System.Enum { }
    }
    public static class Exactly
    {
        public static FluentAssertions.OccurrenceConstraint Once() { }
        public static FluentAssertions.OccurrenceConstraint Thrice() { }
        public static FluentAssertions.OccurrenceConstraint Times(int expected) { }
        public static FluentAssertions.OccurrenceConstraint Twice() { }
    }
    public static class ExceptionAssertionsExtensions
    {
        public static System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> Where<TException>(this System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> task, System.Linq.Expressions.Expression<System.Func<TException, bool>> exceptionExpression, string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
        public static System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<System.Exception>> WithInnerException<TException>(this System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> task, System.Type innerException, string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
        public static System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TInnerException>> WithInnerException<TException, TInnerException>(this System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> task, string because = "", params object[] becauseArgs)
            where TException : System.Exception
            where TInnerException : System.Exception { }
        public static System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<System.Exception>> WithInnerExceptionExactly<TException>(this System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> task, System.Type innerException, string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
        public static System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TInnerException>> WithInnerExceptionExactly<TException, TInnerException>(this System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> task, string because = "", params object[] becauseArgs)
            where TException : System.Exception
            where TInnerException : System.Exception { }
        public static System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> WithMessage<TException>(this System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> task, string expectedWildcardPattern, string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
        public static FluentAssertions.Specialized.ExceptionAssertions<TException> WithParameterName<TException>(this FluentAssertions.Specialized.ExceptionAssertions<TException> parent, string paramName, string because = "", params object[] becauseArgs)
            where TException : System.ArgumentException { }
        public static System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> WithParameterName<TException>(this System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> task, string paramName, string because = "", params object[] becauseArgs)
            where TException : System.ArgumentException { }
    }
    public static class FluentActions
    {
        public static System.Func<System.Threading.Tasks.Task> Awaiting(System.Func<System.Threading.Tasks.Task> action) { }
        public static System.Func<System.Threading.Tasks.Task<T>> Awaiting<T>(System.Func<System.Threading.Tasks.Task<T>> func) { }
        public static System.Action Enumerating(System.Func<System.Collections.IEnumerable> enumerable) { }
        public static System.Action Enumerating<T>(System.Func<System.Collections.Generic.IEnumerable<T>> enumerable) { }
        public static System.Action Invoking(System.Action action) { }
        public static System.Func<T> Invoking<T>(System.Func<T> func) { }
    }
    public static class LessThan
    {
        public static FluentAssertions.OccurrenceConstraint Thrice() { }
        public static FluentAssertions.OccurrenceConstraint Times(int expected) { }
        public static FluentAssertions.OccurrenceConstraint Twice() { }
    }
    public static class License
    {
        public static bool Accepted { get; set; }
    }
    public static class MoreThan
    {
        public static FluentAssertions.OccurrenceConstraint Once() { }
        public static FluentAssertions.OccurrenceConstraint Thrice() { }
        public static FluentAssertions.OccurrenceConstraint Times(int expected) { }
        public static FluentAssertions.OccurrenceConstraint Twice() { }
    }
    public static class NumericAssertionsExtensions
    {
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<decimal>> BeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<decimal> parent, decimal expectedValue, decimal precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<decimal>> BeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<decimal> parent, decimal? expectedValue, decimal precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<double>> BeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<double> parent, double expectedValue, double precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<double>> BeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<double> parent, double? expectedValue, double precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<float>> BeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<float> parent, float expectedValue, float precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<float>> BeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<float> parent, float? expectedValue, float precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<decimal>> BeApproximately(this FluentAssertions.Numeric.NumericAssertions<decimal> parent, decimal expectedValue, decimal precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<double>> BeApproximately(this FluentAssertions.Numeric.NumericAssertions<double> parent, double expectedValue, double precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<float>> BeApproximately(this FluentAssertions.Numeric.NumericAssertions<float> parent, float expectedValue, float precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<byte>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<byte> parent, byte nearbyValue, byte delta, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<short>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<short> parent, short nearbyValue, ushort delta, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<int>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<int> parent, int nearbyValue, uint delta, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<long>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<long> parent, long nearbyValue, ulong delta, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<sbyte>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<sbyte> parent, sbyte nearbyValue, byte delta, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<ushort>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<ushort> parent, ushort nearbyValue, ushort delta, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<uint>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<uint> parent, uint nearbyValue, uint delta, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<ulong>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<ulong> parent, ulong nearbyValue, ulong delta, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<double>> BeNaN(this FluentAssertions.Numeric.NullableNumericAssertions<double> parent, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<float>> BeNaN(this FluentAssertions.Numeric.NullableNumericAssertions<float> parent, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<double>> BeNaN(this FluentAssertions.Numeric.NumericAssertions<double> parent, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<float>> BeNaN(this FluentAssertions.Numeric.NumericAssertions<float> parent, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<decimal>> NotBeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<decimal> parent, decimal unexpectedValue, decimal precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<decimal>> NotBeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<decimal> parent, decimal? unexpectedValue, decimal precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<double>> NotBeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<double> parent, double unexpectedValue, double precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<double>> NotBeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<double> parent, double? unexpectedValue, double precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<float>> NotBeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<float> parent, float unexpectedValue, float precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<float>> NotBeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<float> parent, float? unexpectedValue, float precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<decimal>> NotBeApproximately(this FluentAssertions.Numeric.NumericAssertions<decimal> parent, decimal unexpectedValue, decimal precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<double>> NotBeApproximately(this FluentAssertions.Numeric.NumericAssertions<double> parent, double unexpectedValue, double precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<float>> NotBeApproximately(this FluentAssertions.Numeric.NumericAssertions<float> parent, float unexpectedValue, float precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<byte>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<byte> parent, byte distantValue, byte delta, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<short>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<short> parent, short distantValue, ushort delta, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<int>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<int> parent, int distantValue, uint delta, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<long>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<long> parent, long distantValue, ulong delta, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<sbyte>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<sbyte> parent, sbyte distantValue, byte delta, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<ushort>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<ushort> parent, ushort distantValue, ushort delta, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<uint>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<uint> parent, uint distantValue, uint delta, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<ulong>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<ulong> parent, ulong distantValue, ulong delta, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<double>> NotBeNaN(this FluentAssertions.Numeric.NullableNumericAssertions<double> parent, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<float>> NotBeNaN(this FluentAssertions.Numeric.NullableNumericAssertions<float> parent, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<double>> NotBeNaN(this FluentAssertions.Numeric.NumericAssertions<double> parent, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<float>> NotBeNaN(this FluentAssertions.Numeric.NumericAssertions<float> parent, string because = "", params object[] becauseArgs) { }
    }
    public static class ObjectAssertionsExtensions
    {
        public static FluentAssertions.AndConstraint<FluentAssertions.Primitives.ObjectAssertions> BeDataContractSerializable(this FluentAssertions.Primitives.ObjectAssertions assertions, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Primitives.ObjectAssertions> BeDataContractSerializable<T>(this FluentAssertions.Primitives.ObjectAssertions assertions, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<T>, FluentAssertions.Equivalency.EquivalencyOptions<T>> options, string because = "", params object[] becauseArgs) { }
        public static FluentAssertions.AndConstraint<FluentAssertions.Primitives.ObjectAssertions> BeXmlSerializable(this FluentAssertions.Primitives.ObjectAssertions assertions, string because = "", params object[] becauseArgs) { }
    }
    public abstract class OccurrenceConstraint
    {
        protected OccurrenceConstraint(int expectedCount) { }
    }
    public static class TypeEnumerableExtensions
    {
        public static System.Collections.Generic.IEnumerable<System.Type> ThatAreClasses(this System.Collections.Generic.IEnumerable<System.Type> types) { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatAreDecoratedWith<TAttribute>(this System.Collections.Generic.IEnumerable<System.Type> types)
            where TAttribute : System.Attribute { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatAreDecoratedWithOrInherit<TAttribute>(this System.Collections.Generic.IEnumerable<System.Type> types)
            where TAttribute : System.Attribute { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatAreInNamespace(this System.Collections.Generic.IEnumerable<System.Type> types, string @namespace) { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatAreNotClasses(this System.Collections.Generic.IEnumerable<System.Type> types) { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatAreNotDecoratedWith<TAttribute>(this System.Collections.Generic.IEnumerable<System.Type> types)
            where TAttribute : System.Attribute { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatAreNotDecoratedWithOrInherit<TAttribute>(this System.Collections.Generic.IEnumerable<System.Type> types)
            where TAttribute : System.Attribute { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatAreNotStatic(this System.Collections.Generic.IEnumerable<System.Type> types) { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatAreStatic(this System.Collections.Generic.IEnumerable<System.Type> types) { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatAreUnderNamespace(this System.Collections.Generic.IEnumerable<System.Type> types, string @namespace) { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatDeriveFrom<T>(this System.Collections.Generic.IEnumerable<System.Type> types) { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatImplement<T>(this System.Collections.Generic.IEnumerable<System.Type> types) { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatSatisfy(this System.Collections.Generic.IEnumerable<System.Type> types, System.Func<System.Type, bool> predicate) { }
        public static System.Collections.Generic.IEnumerable<System.Type> UnwrapEnumerableTypes(this System.Collections.Generic.IEnumerable<System.Type> types) { }
        public static System.Collections.Generic.IEnumerable<System.Type> UnwrapTaskTypes(this System.Collections.Generic.IEnumerable<System.Type> types) { }
    }
    public static class TypeExtensions
    {
        public static FluentAssertions.Types.MethodInfoSelector Methods(this FluentAssertions.Types.TypeSelector typeSelector) { }
        public static FluentAssertions.Types.MethodInfoSelector Methods(this System.Type type) { }
        public static FluentAssertions.Types.PropertyInfoSelector Properties(this FluentAssertions.Types.TypeSelector typeSelector) { }
        public static FluentAssertions.Types.PropertyInfoSelector Properties(this System.Type type) { }
        public static FluentAssertions.Types.TypeSelector Types(this System.Collections.Generic.IEnumerable<System.Type> types) { }
        public static FluentAssertions.Types.TypeSelector Types(this System.Reflection.Assembly assembly) { }
        public static FluentAssertions.Types.TypeSelector Types(this System.Type type) { }
    }
    public static class XmlAssertionExtensions
    {
        public static FluentAssertions.Xml.XmlElementAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Xml.XmlElement actualValue) { }
        public static FluentAssertions.Xml.XmlNodeAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Xml.XmlNode actualValue) { }
    }
}
namespace FluentAssertions.Collections
{
    public class GenericCollectionAssertions<T> : FluentAssertions.Collections.GenericCollectionAssertions<System.Collections.Generic.IEnumerable<T>, T, FluentAssertions.Collections.GenericCollectionAssertions<T>>
    {
        public GenericCollectionAssertions(System.Collections.Generic.IEnumerable<T> actualValue, FluentAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class GenericCollectionAssertions<TCollection, T> : FluentAssertions.Collections.GenericCollectionAssertions<TCollection, T, FluentAssertions.Collections.GenericCollectionAssertions<TCollection, T>>
        where TCollection : System.Collections.Generic.IEnumerable<T>
    {
        public GenericCollectionAssertions(TCollection actualValue, FluentAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class GenericCollectionAssertions<TCollection, T, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<TCollection, TAssertions>
        where TCollection : System.Collections.Generic.IEnumerable<T>
        where TAssertions : FluentAssertions.Collections.GenericCollectionAssertions<TCollection, T, TAssertions>
    {
        public GenericCollectionAssertions(TCollection actualValue, FluentAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public FluentAssertions.AndConstraint<TAssertions> AllBeAssignableTo(System.Type expectedType, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<TAssertions, System.Collections.Generic.IEnumerable<TExpectation>> AllBeAssignableTo<TExpectation>(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> AllBeEquivalentTo<TExpectation>(TExpectation expectation, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> AllBeEquivalentTo<TExpectation>(TExpectation expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> AllBeOfType(System.Type expectedType, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<TAssertions, System.Collections.Generic.IEnumerable<TExpectation>> AllBeOfType<TExpectation>(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> AllSatisfy(System.Action<T> expected, string because = "", params object[] becauseArgs) { }
        protected void AssertCollectionEndsWith<TActual, TExpectation>(System.Collections.Generic.IEnumerable<TActual> actual, System.Collections.Generic.ICollection<TExpectation> expected, System.Func<TActual, TExpectation, bool> equalityComparison, string because = "", params object[] becauseArgs) { }
        protected void AssertCollectionStartsWith<TActual, TExpectation>(System.Collections.Generic.IEnumerable<TActual> actualItems, System.Collections.Generic.ICollection<TExpectation> expected, System.Func<TActual, TExpectation, bool> equalityComparison, string because = "", params object[] becauseArgs) { }
        protected void AssertSubjectEquality<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, System.Func<T, TExpectation, bool> equalityComparison, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeEmpty(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInAscendingOrder(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInAscendingOrder(System.Collections.Generic.IComparer<T> comparer, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInAscendingOrder(System.Func<T, T, int> comparison, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInDescendingOrder(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInDescendingOrder(System.Collections.Generic.IComparer<T> comparer, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInDescendingOrder(System.Func<T, T, int> comparison, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeNullOrEmpty(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeSubsetOf(System.Collections.Generic.IEnumerable<T> expectedSuperset, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> Contain(System.Collections.Generic.IEnumerable<T> expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<TAssertions, T> Contain(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<TAssertions, T> Contain(T expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<TAssertions, T> ContainEquivalentOf<TExpectation>(TExpectation expectation, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<TAssertions, T> ContainEquivalentOf<TExpectation>(TExpectation expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> ContainInConsecutiveOrder(params T[] expected) { }
        public FluentAssertions.AndConstraint<TAssertions> ContainInConsecutiveOrder(System.Collections.Generic.IEnumerable<T> expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> ContainInOrder(params T[] expected) { }
        public FluentAssertions.AndConstraint<TAssertions> ContainInOrder(System.Collections.Generic.IEnumerable<T> expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> ContainItemsAssignableTo<TExpectation>(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<TAssertions, T> ContainSingle(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<TAssertions, T> ContainSingle(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> EndWith(System.Collections.Generic.IEnumerable<T> expectation, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> EndWith(T element, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> EndWith<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, System.Func<T, TExpectation, bool> equalityComparison, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> Equal(params T[] elements) { }
        public FluentAssertions.AndConstraint<TAssertions> Equal(System.Collections.Generic.IEnumerable<T> expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> Equal<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, System.Func<T, TExpectation, bool> equalityComparison, string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveCount(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveCount(System.Linq.Expressions.Expression<System.Func<int, bool>> countPredicate, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveCountGreaterThan(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveCountGreaterThanOrEqualTo(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveCountLessThan(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveCountLessThanOrEqualTo(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<TAssertions, T> HaveElementAt(int index, T element, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveElementPreceding(T successor, T expectation, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveElementSucceeding(T predecessor, T expectation, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveSameCount<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> otherCollection, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> IntersectWith(System.Collections.Generic.IEnumerable<T> otherCollection, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeEmpty(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeEquivalentTo<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeEquivalentTo<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> unexpected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeInAscendingOrder(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeInAscendingOrder(System.Collections.Generic.IComparer<T> comparer, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeInAscendingOrder(System.Func<T, T, int> comparison, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeInDescendingOrder(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeInDescendingOrder(System.Collections.Generic.IComparer<T> comparer, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeInDescendingOrder(System.Func<T, T, int> comparison, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeNullOrEmpty(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeSubsetOf(System.Collections.Generic.IEnumerable<T> unexpectedSuperset, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotContain(System.Collections.Generic.IEnumerable<T> unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotContain(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotContain(T unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotContainEquivalentOf<TExpectation>(TExpectation unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotContainEquivalentOf<TExpectation>(TExpectation unexpected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotContainInConsecutiveOrder(params T[] unexpected) { }
        public FluentAssertions.AndConstraint<TAssertions> NotContainInConsecutiveOrder(System.Collections.Generic.IEnumerable<T> unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotContainInOrder(params T[] unexpected) { }
        public FluentAssertions.AndConstraint<TAssertions> NotContainInOrder(System.Collections.Generic.IEnumerable<T> unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotContainItemsAssignableTo(System.Type type, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotContainItemsAssignableTo<TExpectation>(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotContainNulls(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotContainNulls<TKey>(System.Linq.Expressions.Expression<System.Func<T, TKey>> predicate, string because = "", params object[] becauseArgs)
            where TKey :  class { }
        public FluentAssertions.AndConstraint<TAssertions> NotEqual(System.Collections.Generic.IEnumerable<T> unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotHaveCount(int unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotHaveSameCount<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> otherCollection, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotIntersectWith(System.Collections.Generic.IEnumerable<T> otherCollection, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> OnlyContain(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> OnlyHaveUniqueItems(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> OnlyHaveUniqueItems<TKey>(System.Linq.Expressions.Expression<System.Func<T, TKey>> predicate, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> Satisfy(params System.Linq.Expressions.Expression<System.Func<T, bool>>[] predicates) { }
        public FluentAssertions.AndConstraint<TAssertions> Satisfy(System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression<System.Func<T, bool>>> predicates, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> SatisfyRespectively(params System.Action<T>[] elementInspectors) { }
        public FluentAssertions.AndConstraint<TAssertions> SatisfyRespectively(System.Collections.Generic.IEnumerable<System.Action<T>> expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> StartWith(System.Collections.Generic.IEnumerable<T> expectation, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> StartWith(T element, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> StartWith<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, System.Func<T, TExpectation, bool> equalityComparison, string because = "", params object[] becauseArgs) { }
        protected static System.Collections.Generic.IEnumerable<TExpectation> RepeatAsManyAs<TExpectation>(TExpectation value, System.Collections.Generic.IEnumerable<T> enumerable) { }
    }
    public class GenericDictionaryAssertions<TCollection, TKey, TValue> : FluentAssertions.Collections.GenericDictionaryAssertions<TCollection, TKey, TValue, FluentAssertions.Collections.GenericDictionaryAssertions<TCollection, TKey, TValue>>
        where TCollection : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>
    {
        public GenericDictionaryAssertions(TCollection keyValuePairs, FluentAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class GenericDictionaryAssertions<TCollection, TKey, TValue, TAssertions> : FluentAssertions.Collections.GenericCollectionAssertions<TCollection, System.Collections.Generic.KeyValuePair<TKey, TValue>, TAssertions>
        where TCollection : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>
        where TAssertions : FluentAssertions.Collections.GenericDictionaryAssertions<TCollection, TKey, TValue, TAssertions>
    {
        public GenericDictionaryAssertions(TCollection keyValuePairs, FluentAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> Contain(params System.Collections.Generic.KeyValuePair<TKey, TValue>[] expected) { }
        public FluentAssertions.AndConstraint<TAssertions> Contain(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> Contain(System.Collections.Generic.KeyValuePair<TKey, TValue> expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> Contain(TKey key, TValue value, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.Collections.WhoseValueConstraint<TCollection, TKey, TValue, TAssertions> ContainKey(TKey expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> ContainKeys(params TKey[] expected) { }
        public FluentAssertions.AndConstraint<TAssertions> ContainKeys(System.Collections.Generic.IEnumerable<TKey> expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<TAssertions, TValue> ContainValue(TValue expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<TAssertions, System.Collections.Generic.IEnumerable<TValue>> ContainValues(params TValue[] expected) { }
        public FluentAssertions.AndWhichConstraint<TAssertions, System.Collections.Generic.IEnumerable<TValue>> ContainValues(System.Collections.Generic.IEnumerable<TValue> expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> Equal<T>(T expected, string because = "", params object[] becauseArgs)
            where T : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> { }
        public FluentAssertions.AndConstraint<TAssertions> NotContain(params System.Collections.Generic.KeyValuePair<TKey, TValue>[] items) { }
        public FluentAssertions.AndConstraint<TAssertions> NotContain(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> items, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotContain(System.Collections.Generic.KeyValuePair<TKey, TValue> item, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotContain(TKey key, TValue value, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotContainKey(TKey unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotContainKeys(params TKey[] unexpected) { }
        public FluentAssertions.AndConstraint<TAssertions> NotContainKeys(System.Collections.Generic.IEnumerable<TKey> unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotContainValue(TValue unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotContainValues(params TValue[] unexpected) { }
        public FluentAssertions.AndConstraint<TAssertions> NotContainValues(System.Collections.Generic.IEnumerable<TValue> unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotEqual<T>(T unexpected, string because = "", params object[] becauseArgs)
            where T : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> { }
    }
    public class StringCollectionAssertions : FluentAssertions.Collections.StringCollectionAssertions<System.Collections.Generic.IEnumerable<string>>
    {
        public StringCollectionAssertions(System.Collections.Generic.IEnumerable<string> actualValue, FluentAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class StringCollectionAssertions<TCollection> : FluentAssertions.Collections.StringCollectionAssertions<TCollection, FluentAssertions.Collections.StringCollectionAssertions<TCollection>>
        where TCollection : System.Collections.Generic.IEnumerable<string>
    {
        public StringCollectionAssertions(TCollection actualValue, FluentAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class StringCollectionAssertions<TCollection, TAssertions> : FluentAssertions.Collections.GenericCollectionAssertions<TCollection, string, TAssertions>
        where TCollection : System.Collections.Generic.IEnumerable<string>
        where TAssertions : FluentAssertions.Collections.StringCollectionAssertions<TCollection, TAssertions>
    {
        public StringCollectionAssertions(TCollection actualValue, FluentAssertions.Execution.AssertionChain assertionChain) { }
        public FluentAssertions.AndConstraint<TAssertions> AllBe(string expectation, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> AllBe(string expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo(params string[] expectation) { }
        public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo(System.Collections.Generic.IEnumerable<string> expectation, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo(System.Collections.Generic.IEnumerable<string> expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<TAssertions, string> ContainMatch(string wildcardPattern, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> Equal(System.Collections.Generic.IEnumerable<string> expected) { }
        public FluentAssertions.AndConstraint<TAssertions> Equal(params string[] expected) { }
        public FluentAssertions.AndConstraint<TAssertions> NotContainMatch(string wildcardPattern, string because = "", params object[] becauseArgs) { }
    }
    public class SubsequentOrderingAssertions<T> : FluentAssertions.Collections.GenericCollectionAssertions<System.Collections.Generic.IEnumerable<T>, T>
    {
        public SubsequentOrderingAssertions(System.Collections.Generic.IEnumerable<T> actualValue, System.Linq.IOrderedEnumerable<T> previousOrderedEnumerable, FluentAssertions.Execution.AssertionChain assertionChain) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> ThenBeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> ThenBeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> ThenBeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> ThenBeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, string because = "", params object[] becauseArgs) { }
    }
    public class WhoseValueConstraint<TCollection, TKey, TValue, TAssertions> : FluentAssertions.AndConstraint<TAssertions>
        where TCollection : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>
        where TAssertions : FluentAssertions.Collections.GenericDictionaryAssertions<TCollection, TKey, TValue, TAssertions>
    {
        public WhoseValueConstraint(TAssertions parentConstraint, TValue value) { }
        public TValue WhoseValue { get; }
    }
}
namespace FluentAssertions.Common
{
    public enum CSharpAccessModifier
    {
        Public = 0,
        Private = 1,
        Protected = 2,
        Internal = 3,
        ProtectedInternal = 4,
        InvalidForCSharp = 5,
        PrivateProtected = 6,
    }
    public static class DateTimeExtensions
    {
        public static System.DateTimeOffset ToDateTimeOffset(this System.DateTime dateTime) { }
        public static System.DateTimeOffset ToDateTimeOffset(this System.DateTime dateTime, System.TimeSpan offset) { }
    }
    public interface IClock
    {
        void Delay(System.TimeSpan timeToDelay);
        System.Threading.Tasks.Task DelayAsync(System.TimeSpan delay, System.Threading.CancellationToken cancellationToken);
        FluentAssertions.Common.ITimer StartTimer();
    }
    public interface ITimer : System.IDisposable
    {
        System.TimeSpan Elapsed { get; }
    }
    public delegate FluentAssertions.Common.ITimer StartTimer();
    public enum ValueFormatterDetectionMode
    {
        Disabled = 0,
        Specific = 1,
        Scan = 2,
    }
}
namespace FluentAssertions.Configuration
{
    public class GlobalConfiguration
    {
        public GlobalConfiguration() { }
        public FluentAssertions.Configuration.GlobalEquivalencyOptions Equivalency { get; set; }
        public FluentAssertions.Configuration.GlobalFormattingOptions Formatting { get; set; }
        public FluentAssertions.Configuration.TestFramework? TestFramework { get; set; }
    }
    public class GlobalEquivalencyOptions
    {
        public GlobalEquivalencyOptions() { }
        public FluentAssertions.Equivalency.EquivalencyPlan Plan { get; }
        public FluentAssertions.Equivalency.EquivalencyOptions<T> CloneDefaults<T>() { }
        public void Modify(System.Func<FluentAssertions.Equivalency.EquivalencyOptions, FluentAssertions.Equivalency.EquivalencyOptions> configureOptions) { }
    }
    public class GlobalFormattingOptions : FluentAssertions.Formatting.FormattingOptions
    {
        public GlobalFormattingOptions() { }
        public string ValueFormatterAssembly { get; set; }
        public FluentAssertions.Common.ValueFormatterDetectionMode ValueFormatterDetectionMode { get; set; }
    }
    public enum TestFramework
    {
        XUnit2 = 0,
        XUnit3 = 1,
        TUnit = 2,
        MsTest = 3,
        NUnit = 4,
        MSpec = 5,
    }
}
namespace FluentAssertions.Equivalency
{
    public class Comparands
    {
        public Comparands() { }
        public Comparands(object subject, object expectation, System.Type compileTimeType) { }
        public System.Type CompileTimeType { get; set; }
        public object Expectation { get; set; }
        public System.Type RuntimeType { get; }
        public object Subject { get; set; }
        public System.Type GetExpectedType(FluentAssertions.Equivalency.IEquivalencyOptions options) { }
        public override string ToString() { }
    }
    public class ConversionSelector
    {
        public ConversionSelector() { }
        public FluentAssertions.Equivalency.ConversionSelector Clone() { }
        public void Exclude(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate) { }
        public void Include(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate) { }
        public void IncludeAll() { }
        public bool RequiresConversion(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.INode currentNode) { }
        public override string ToString() { }
    }
    public enum CyclicReferenceHandling
    {
        Ignore = 0,
        ThrowException = 1,
    }
    public enum EnumEquivalencyHandling
    {
        ByValue = 0,
        ByName = 1,
    }
    public enum EqualityStrategy
    {
        Equals = 0,
        Members = 1,
        ForceEquals = 2,
        ForceMembers = 3,
    }
    public class EquivalencyOptions : FluentAssertions.Equivalency.SelfReferenceEquivalencyOptions<FluentAssertions.Equivalency.EquivalencyOptions>
    {
        public EquivalencyOptions() { }
    }
    public class EquivalencyOptions<TExpectation> : FluentAssertions.Equivalency.SelfReferenceEquivalencyOptions<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>>
    {
        public EquivalencyOptions() { }
        public EquivalencyOptions(FluentAssertions.Equivalency.IEquivalencyOptions defaults) { }
        public FluentAssertions.Equivalency.EquivalencyOptions<System.Collections.Generic.IEnumerable<TExpectation>> AsCollection() { }
        public FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> Excluding(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expression) { }
        public FluentAssertions.Equivalency.NestedExclusionOptionBuilder<TExpectation, TNext> For<TNext>(System.Linq.Expressions.Expression<System.Func<TExpectation, System.Collections.Generic.IEnumerable<TNext>>> expression) { }
        public FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> Including(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expression) { }
        public FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> WithMapping(string expectationMemberPath, string subjectMemberPath) { }
        public FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> WithMapping<TSubject>(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expectationMemberPath, System.Linq.Expressions.Expression<System.Func<TSubject, object>> subjectMemberPath) { }
        public FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> WithMapping<TNestedExpectation, TNestedSubject>(System.Linq.Expressions.Expression<System.Func<TNestedExpectation, object>> expectationMember, System.Linq.Expressions.Expression<System.Func<TNestedSubject, object>> subjectMember) { }
        public FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> WithMapping<TNestedExpectation, TNestedSubject>(string expectationMemberName, string subjectMemberName) { }
        public FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> WithStrictOrderingFor(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expression) { }
        public FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> WithoutStrictOrderingFor(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expression) { }
    }
    public class EquivalencyPlan : System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IEquivalencyStep>, System.Collections.IEnumerable
    {
        public EquivalencyPlan() { }
        public void Add<TStep>()
            where TStep : FluentAssertions.Equivalency.IEquivalencyStep, new () { }
        public void AddAfter<TPredecessor, TStep>()
            where TStep : FluentAssertions.Equivalency.IEquivalencyStep, new () { }
        public void Clear() { }
        public System.Collections.Generic.IEnumerator<FluentAssertions.Equivalency.IEquivalencyStep> GetEnumerator() { }
        public void Insert<TStep>()
            where TStep : FluentAssertions.Equivalency.IEquivalencyStep, new () { }
        public void InsertBefore<TSuccessor, TStep>()
            where TStep : FluentAssertions.Equivalency.IEquivalencyStep, new () { }
        public void Remove<TStep>()
            where TStep : FluentAssertions.Equivalency.IEquivalencyStep { }
        public void Reset() { }
    }
    public enum EquivalencyResult
    {
        ContinueWithNext = 0,
        EquivalencyProven = 1,
    }
    public abstract class EquivalencyStep<T> : FluentAssertions.Equivalency.IEquivalencyStep
    {
        protected EquivalencyStep() { }
        public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }
        protected abstract FluentAssertions.Equivalency.EquivalencyResult OnHandle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency nestedValidator);
    }
    public class EquivalencyValidationContext : FluentAssertions.Equivalency.IEquivalencyValidationContext
    {
        public EquivalencyValidationContext(FluentAssertions.Equivalency.INode root, FluentAssertions.Equivalency.IEquivalencyOptions options) { }
        public FluentAssertions.Equivalency.INode CurrentNode { get; }
        public FluentAssertions.Equivalency.IEquivalencyOptions Options { get; }
        public FluentAssertions.Execution.Reason Reason { get; set; }
        public FluentAssertions.Equivalency.Tracing.ITraceWriter TraceWriter { get; set; }
        public FluentAssertions.Equivalency.Tracing.Tracer Tracer { get; }
        public FluentAssertions.Equivalency.IEquivalencyValidationContext AsCollectionItem<TItem>(string index) { }
        public FluentAssertions.Equivalency.IEquivalencyValidationContext AsDictionaryItem<TKey, TExpectation>(TKey key) { }
        public FluentAssertions.Equivalency.IEquivalencyValidationContext AsNestedMember(FluentAssertions.Equivalency.IMember expectationMember) { }
        public FluentAssertions.Equivalency.IEquivalencyValidationContext Clone() { }
        public bool IsCyclicReference(object expectation) { }
        public override string ToString() { }
    }
    public delegate string GetSubjectId();
    public interface IAssertionContext<TSubject>
    {
        string Because { get; set; }
        object[] BecauseArgs { get; set; }
        TSubject Expectation { get; }
        FluentAssertions.Equivalency.INode SelectedNode { get; }
        TSubject Subject { get; }
    }
    public interface IEquivalencyOptions
    {
        bool AllowInfiniteRecursion { get; }
        bool? CompareRecordsByValue { get; }
        FluentAssertions.Equivalency.ConversionSelector ConversionSelector { get; }
        FluentAssertions.Equivalency.CyclicReferenceHandling CyclicReferenceHandling { get; }
        FluentAssertions.Equivalency.EnumEquivalencyHandling EnumEquivalencyHandling { get; }
        bool ExcludeNonBrowsableOnExpectation { get; }
        bool IgnoreCase { get; }
        bool IgnoreLeadingWhitespace { get; }
        bool IgnoreNewlineStyle { get; }
        bool IgnoreNonBrowsableOnSubject { get; }
        bool IgnoreTrailingWhitespace { get; }
        FluentAssertions.Equivalency.MemberVisibility IncludedFields { get; }
        FluentAssertions.Equivalency.MemberVisibility IncludedProperties { get; }
        bool IsRecursive { get; }
        System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IMemberMatchingRule> MatchingRules { get; }
        FluentAssertions.Equivalency.OrderingRuleCollection OrderingRules { get; }
        System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IMemberSelectionRule> SelectionRules { get; }
        FluentAssertions.Equivalency.Tracing.ITraceWriter TraceWriter { get; }
        bool UseRuntimeTyping { get; }
        System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IEquivalencyStep> UserEquivalencySteps { get; }
        FluentAssertions.Equivalency.EqualityStrategy GetEqualityStrategy(System.Type type);
    }
    public interface IEquivalencyStep
    {
        FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes);
    }
    public interface IEquivalencyValidationContext
    {
        FluentAssertions.Equivalency.INode CurrentNode { get; }
        FluentAssertions.Equivalency.IEquivalencyOptions Options { get; }
        FluentAssertions.Execution.Reason Reason { get; }
        FluentAssertions.Equivalency.Tracing.Tracer Tracer { get; }
        FluentAssertions.Equivalency.IEquivalencyValidationContext AsCollectionItem<TItem>(string index);
        FluentAssertions.Equivalency.IEquivalencyValidationContext AsDictionaryItem<TKey, TExpectation>(TKey key);
        FluentAssertions.Equivalency.IEquivalencyValidationContext AsNestedMember(FluentAssertions.Equivalency.IMember expectationMember);
        FluentAssertions.Equivalency.IEquivalencyValidationContext Clone();
        bool IsCyclicReference(object expectation);
    }
    public interface IMember : FluentAssertions.Equivalency.INode
    {
        System.Type DeclaringType { get; }
        FluentAssertions.Common.CSharpAccessModifier GetterAccessibility { get; }
        bool IsBrowsable { get; }
        System.Type ReflectedType { get; }
        FluentAssertions.Common.CSharpAccessModifier SetterAccessibility { get; }
        object GetValue(object obj);
    }
    public interface IMemberInfo
    {
        System.Type DeclaringType { get; }
        FluentAssertions.Common.CSharpAccessModifier GetterAccessibility { get; }
        string Name { get; }
        string Path { get; set; }
        FluentAssertions.Common.CSharpAccessModifier SetterAccessibility { get; }
        System.Type Type { get; }
    }
    public interface IMemberMatchingRule
    {
        FluentAssertions.Equivalency.IMember Match(FluentAssertions.Equivalency.IMember expectedMember, object subject, FluentAssertions.Equivalency.INode parent, FluentAssertions.Equivalency.IEquivalencyOptions options, FluentAssertions.Execution.AssertionChain assertionChain);
    }
    public interface IMemberSelectionRule
    {
        bool IncludesMembers { get; }
        System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IMember> SelectMembers(FluentAssertions.Equivalency.INode currentNode, System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IMember> selectedMembers, FluentAssertions.Equivalency.MemberSelectionContext context);
    }
    public interface INode
    {
        int Depth { get; }
        FluentAssertions.Equivalency.Pathway Expectation { get; }
        FluentAssertions.Equivalency.GetSubjectId GetSubjectId { get; }
        bool IsRoot { get; }
        System.Type ParentType { get; }
        bool RootIsCollection { get; }
        FluentAssertions.Equivalency.Pathway Subject { get; }
        System.Type Type { get; }
        void AdjustForRemappedSubject(FluentAssertions.Equivalency.IMember subjectMember);
    }
    public interface IObjectInfo
    {
        System.Type CompileTimeType { get; }
        System.Type ParentType { get; }
        string Path { get; set; }
        System.Type RuntimeType { get; }
        [System.Obsolete("Use CompileTimeType or RuntimeType instead")]
        System.Type Type { get; }
    }
    public interface IOrderingRule
    {
        FluentAssertions.Equivalency.OrderStrictness Evaluate(FluentAssertions.Equivalency.IObjectInfo objectInfo);
    }
    public interface IValidateChildNodeEquivalency
    {
        void AssertEquivalencyOf(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context);
    }
    public static class MemberFactory
    {
        public static FluentAssertions.Equivalency.IMember Create(System.Reflection.MemberInfo memberInfo, FluentAssertions.Equivalency.INode parent) { }
    }
    public class MemberSelectionContext
    {
        public MemberSelectionContext(System.Type compileTimeType, System.Type runtimeType, FluentAssertions.Equivalency.IEquivalencyOptions options) { }
        public FluentAssertions.Equivalency.MemberVisibility IncludedFields { get; }
        public FluentAssertions.Equivalency.MemberVisibility IncludedProperties { get; }
        public System.Type Type { get; }
    }
    [System.Flags]
    public enum MemberVisibility
    {
        None = 0,
        Internal = 1,
        Public = 2,
        ExplicitlyImplemented = 4,
        DefaultInterfaceProperties = 8,
    }
    public class NestedExclusionOptionBuilder<TExpectation, TCurrent>
    {
        public FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> Exclude(System.Linq.Expressions.Expression<System.Func<TCurrent, object>> expression) { }
        public FluentAssertions.Equivalency.NestedExclusionOptionBuilder<TExpectation, TNext> For<TNext>(System.Linq.Expressions.Expression<System.Func<TCurrent, System.Collections.Generic.IEnumerable<TNext>>> expression) { }
    }
    public enum OrderStrictness
    {
        Strict = 0,
        NotStrict = 1,
        Irrelevant = 2,
    }
    public class OrderingRuleCollection : System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IOrderingRule>, System.Collections.IEnumerable
    {
        public OrderingRuleCollection() { }
        public OrderingRuleCollection(System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IOrderingRule> orderingRules) { }
        public void Add(FluentAssertions.Equivalency.IOrderingRule rule) { }
        public System.Collections.Generic.IEnumerator<FluentAssertions.Equivalency.IOrderingRule> GetEnumerator() { }
        public bool IsOrderingStrictFor(FluentAssertions.Equivalency.IObjectInfo objectInfo) { }
    }
    public class Pathway : System.IEquatable<FluentAssertions.Equivalency.Pathway>
    {
        public Pathway(FluentAssertions.Equivalency.Pathway parent, string name, FluentAssertions.Equivalency.Pathway.GetDescription getDescription) { }
        public Pathway(string path, string name, FluentAssertions.Equivalency.Pathway.GetDescription getDescription) { }
        public string Description { get; }
        public string Name { get; }
        public string Path { get; }
        public string PathAndName { get; }
        public override string ToString() { }
        public delegate string GetDescription(string pathAndName);
    }
    public abstract class SelfReferenceEquivalencyOptions<TSelf> : FluentAssertions.Equivalency.IEquivalencyOptions
        where TSelf : FluentAssertions.Equivalency.SelfReferenceEquivalencyOptions<TSelf>
    {
        protected SelfReferenceEquivalencyOptions(FluentAssertions.Equivalency.IEquivalencyOptions defaults) { }
        public bool? CompareRecordsByValue { get; }
        public FluentAssertions.Equivalency.ConversionSelector ConversionSelector { get; }
        public bool IgnoreCase { get; }
        public bool IgnoreLeadingWhitespace { get; }
        public bool IgnoreNewlineStyle { get; }
        public bool IgnoreTrailingWhitespace { get; }
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        protected FluentAssertions.Equivalency.OrderingRuleCollection OrderingRules { get; }
        public FluentAssertions.Equivalency.Tracing.ITraceWriter TraceWriter { get; }
        protected TSelf AddMatchingRule(FluentAssertions.Equivalency.IMemberMatchingRule matchingRule) { }
        protected TSelf AddSelectionRule(FluentAssertions.Equivalency.IMemberSelectionRule selectionRule) { }
        public TSelf AllowingInfiniteRecursion() { }
        public TSelf ComparingByMembers(System.Type type) { }
        public TSelf ComparingByMembers<T>() { }
        public TSelf ComparingByValue(System.Type type) { }
        public TSelf ComparingByValue<T>() { }
        public TSelf ComparingEnumsByName() { }
        public TSelf ComparingEnumsByValue() { }
        public TSelf ComparingRecordsByMembers() { }
        public TSelf ComparingRecordsByValue() { }
        public TSelf Excluding(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IMemberInfo, bool>> predicate) { }
        public TSelf ExcludingExplicitlyImplementedProperties() { }
        public TSelf ExcludingFields() { }
        public TSelf ExcludingMembersNamed(params string[] memberNames) { }
        public TSelf ExcludingMissingMembers() { }
        public TSelf ExcludingNonBrowsableMembers() { }
        public TSelf ExcludingProperties() { }
        public TSelf IgnoringCase() { }
        public TSelf IgnoringCyclicReferences() { }
        public TSelf IgnoringLeadingWhitespace() { }
        public TSelf IgnoringNewlineStyle() { }
        public TSelf IgnoringNonBrowsableMembersOnSubject() { }
        public TSelf IgnoringTrailingWhitespace() { }
        public TSelf Including(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IMemberInfo, bool>> predicate) { }
        public TSelf IncludingAllDeclaredProperties() { }
        public TSelf IncludingAllRuntimeProperties() { }
        public TSelf IncludingFields() { }
        public TSelf IncludingInternalFields() { }
        public TSelf IncludingInternalProperties() { }
        public TSelf IncludingNestedObjects() { }
        public TSelf IncludingProperties() { }
        public TSelf PreferringDeclaredMemberTypes() { }
        public TSelf PreferringRuntimeMemberTypes() { }
        public TSelf ThrowingOnMissingMembers() { }
        public override string ToString() { }
        public TSelf Using(FluentAssertions.Equivalency.IEquivalencyStep equivalencyStep) { }
        public TSelf Using(FluentAssertions.Equivalency.IMemberMatchingRule matchingRule) { }
        public TSelf Using(FluentAssertions.Equivalency.IMemberSelectionRule selectionRule) { }
        public TSelf Using(FluentAssertions.Equivalency.IOrderingRule orderingRule) { }
        public TSelf Using(System.Collections.Generic.IEqualityComparer<string> comparer) { }
        public FluentAssertions.Equivalency.SelfReferenceEquivalencyOptions<TSelf>.Restriction<TProperty> Using<TProperty>(System.Action<FluentAssertions.Equivalency.IAssertionContext<TProperty>> action) { }
        public TSelf Using<T>(System.Collections.Generic.IEqualityComparer<T> comparer) { }
        public TSelf Using<T, TEqualityComparer>()
            where TEqualityComparer : System.Collections.Generic.IEqualityComparer<T>, new () { }
        public TSelf WithAutoConversion() { }
        public TSelf WithAutoConversionFor(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate) { }
        public TSelf WithStrictOrdering() { }
        public TSelf WithStrictOrderingFor(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate) { }
        public TSelf WithTracing(FluentAssertions.Equivalency.Tracing.ITraceWriter writer = null) { }
        public TSelf WithoutAutoConversionFor(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate) { }
        public TSelf WithoutMatchingRules() { }
        public TSelf WithoutRecursing() { }
        public TSelf WithoutSelectionRules() { }
        public TSelf WithoutStrictOrdering() { }
        public TSelf WithoutStrictOrderingFor(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate) { }
        public class Restriction<TMember>
        {
            public Restriction(TSelf options, System.Action<FluentAssertions.Equivalency.IAssertionContext<TMember>> action) { }
            public TSelf When(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate) { }
            public TSelf WhenTypeIs<TMemberType>()
                where TMemberType : TMember { }
        }
    }
    public static class SubjectInfoExtensions
    {
        public static bool WhichGetterDoesNotHave(this FluentAssertions.Equivalency.IMemberInfo memberInfo, FluentAssertions.Common.CSharpAccessModifier accessModifier) { }
        public static bool WhichGetterHas(this FluentAssertions.Equivalency.IMemberInfo memberInfo, FluentAssertions.Common.CSharpAccessModifier accessModifier) { }
        public static bool WhichSetterDoesNotHave(this FluentAssertions.Equivalency.IMemberInfo memberInfo, FluentAssertions.Common.CSharpAccessModifier accessModifier) { }
        public static bool WhichSetterHas(this FluentAssertions.Equivalency.IMemberInfo memberInfo, FluentAssertions.Common.CSharpAccessModifier accessModifier) { }
    }
}
namespace FluentAssertions.Equivalency.Steps
{
    public class AssertionRuleEquivalencyStep<TSubject> : FluentAssertions.Equivalency.IEquivalencyStep
    {
        public AssertionRuleEquivalencyStep(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate, System.Action<FluentAssertions.Equivalency.IAssertionContext<TSubject>> assertionAction) { }
        public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }
        public override string ToString() { }
    }
    public class AutoConversionStep : FluentAssertions.Equivalency.IEquivalencyStep
    {
        public AutoConversionStep() { }
        public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }
        public override string ToString() { }
    }
    public class DateAndTimeEquivalencyStep : FluentAssertions.Equivalency.IEquivalencyStep
    {
        public DateAndTimeEquivalencyStep() { }
        public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }
    }
    public class DictionaryEquivalencyStep : FluentAssertions.Equivalency.EquivalencyStep<System.Collections.IDictionary>
    {
        public DictionaryEquivalencyStep() { }
        protected override FluentAssertions.Equivalency.EquivalencyResult OnHandle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency nestedValidator) { }
    }
    public class EnumEqualityStep : FluentAssertions.Equivalency.IEquivalencyStep
    {
        public EnumEqualityStep() { }
        public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }
    }
    public class EnumerableEquivalencyStep : FluentAssertions.Equivalency.IEquivalencyStep
    {
        public EnumerableEquivalencyStep() { }
        public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }
    }
    public class EqualityComparerEquivalencyStep<T> : FluentAssertions.Equivalency.IEquivalencyStep
    {
        public EqualityComparerEquivalencyStep(System.Collections.Generic.IEqualityComparer<T> comparer) { }
        public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }
        public override string ToString() { }
    }
    public class GenericDictionaryEquivalencyStep : FluentAssertions.Equivalency.IEquivalencyStep
    {
        public GenericDictionaryEquivalencyStep() { }
        public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }
    }
    public class GenericEnumerableEquivalencyStep : FluentAssertions.Equivalency.IEquivalencyStep
    {
        public GenericEnumerableEquivalencyStep() { }
        public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }
    }
    public class ReferenceEqualityEquivalencyStep : FluentAssertions.Equivalency.IEquivalencyStep
    {
        public ReferenceEqualityEquivalencyStep() { }
        public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }
    }
    public class RunAllUserStepsEquivalencyStep : FluentAssertions.Equivalency.IEquivalencyStep
    {
        public RunAllUserStepsEquivalencyStep() { }
        public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }
    }
    public class SimpleEqualityEquivalencyStep : FluentAssertions.Equivalency.IEquivalencyStep
    {
        public SimpleEqualityEquivalencyStep() { }
        public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }
    }
    public class StringEqualityEquivalencyStep : FluentAssertions.Equivalency.IEquivalencyStep
    {
        public StringEqualityEquivalencyStep() { }
        public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }
    }
    public class StructuralEqualityEquivalencyStep : FluentAssertions.Equivalency.IEquivalencyStep
    {
        public StructuralEqualityEquivalencyStep() { }
        public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }
    }
    public class ValueTypeEquivalencyStep : FluentAssertions.Equivalency.IEquivalencyStep
    {
        public ValueTypeEquivalencyStep() { }
        public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }
    }
    public class XAttributeEquivalencyStep : FluentAssertions.Equivalency.EquivalencyStep<System.Xml.Linq.XAttribute>
    {
        public XAttributeEquivalencyStep() { }
        protected override FluentAssertions.Equivalency.EquivalencyResult OnHandle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency nestedValidator) { }
    }
    public class XDocumentEquivalencyStep : FluentAssertions.Equivalency.EquivalencyStep<System.Xml.Linq.XDocument>
    {
        public XDocumentEquivalencyStep() { }
        protected override FluentAssertions.Equivalency.EquivalencyResult OnHandle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency nestedValidator) { }
    }
    public class XElementEquivalencyStep : FluentAssertions.Equivalency.EquivalencyStep<System.Xml.Linq.XElement>
    {
        public XElementEquivalencyStep() { }
        protected override FluentAssertions.Equivalency.EquivalencyResult OnHandle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency nestedValidator) { }
    }
}
namespace FluentAssertions.Equivalency.Tracing
{
    public delegate string GetTraceMessage(FluentAssertions.Equivalency.INode node);
    public interface ITraceWriter
    {
        System.IDisposable AddBlock(string trace);
        void AddSingle(string trace);
        string ToString();
    }
    public class StringBuilderTraceWriter : FluentAssertions.Equivalency.Tracing.ITraceWriter
    {
        public StringBuilderTraceWriter() { }
        public System.IDisposable AddBlock(string trace) { }
        public void AddSingle(string trace) { }
        public override string ToString() { }
    }
    public class Tracer
    {
        public override string ToString() { }
        public System.IDisposable WriteBlock(FluentAssertions.Equivalency.Tracing.GetTraceMessage getTraceMessage) { }
        public void WriteLine(FluentAssertions.Equivalency.Tracing.GetTraceMessage getTraceMessage) { }
    }
}
namespace FluentAssertions.Execution
{
    public sealed class AssertionChain
    {
        public string CallerIdentifier { get; }
        public bool HasOverriddenCallerIdentifier { get; }
        public bool Succeeded { get; }
        public FluentAssertions.Execution.AssertionChain UsingLineBreaks { get; }
        public void AddReportable(string key, System.Func<string> getValue) { }
        public void AddReportable(string key, string value) { }
        public FluentAssertions.Execution.AssertionChain BecauseOf(FluentAssertions.Execution.Reason reason) { }
        public FluentAssertions.Execution.AssertionChain BecauseOf(string because, params object[] becauseArgs) { }
        public FluentAssertions.Execution.Continuation FailWith(System.Func<FluentAssertions.Execution.FailReason> getFailureReason) { }
        public FluentAssertions.Execution.Continuation FailWith(string message) { }
        public FluentAssertions.Execution.Continuation FailWith(string message, params System.Func<object>[] argProviders) { }
        public FluentAssertions.Execution.Continuation FailWith(string message, params object[] args) { }
        public FluentAssertions.Execution.AssertionChain ForCondition(bool condition) { }
        public FluentAssertions.Execution.AssertionChain ForConstraint(FluentAssertions.OccurrenceConstraint constraint, int actualOccurrences) { }
        public FluentAssertions.Execution.GivenSelector<T> Given<T>(System.Func<T> selector) { }
        public void OverrideCallerIdentifier(System.Func<string> getCallerIdentifier) { }
        public void ReuseOnce() { }
        public FluentAssertions.Execution.AssertionChain WithCallerPostfix(string postfix) { }
        public FluentAssertions.Execution.AssertionChain WithDefaultIdentifier(string identifier) { }
        public FluentAssertions.Execution.Continuation WithExpectation(string message, System.Action<FluentAssertions.Execution.AssertionChain> chain) { }
        public FluentAssertions.Execution.Continuation WithExpectation(string message, object arg1, System.Action<FluentAssertions.Execution.AssertionChain> chain) { }
        public FluentAssertions.Execution.Continuation WithExpectation(string message, object arg1, object arg2, System.Action<FluentAssertions.Execution.AssertionChain> chain) { }
        public FluentAssertions.Execution.AssertionChain WithReportable(string name, System.Func<string> content) { }
        public static FluentAssertions.Execution.AssertionChain GetOrCreate() { }
    }
    public class AssertionFailedException : System.Exception
    {
        public AssertionFailedException(string message) { }
    }
    public sealed class AssertionScope : System.IDisposable
    {
        public AssertionScope() { }
        public AssertionScope(FluentAssertions.Execution.IAssertionStrategy assertionStrategy) { }
        public AssertionScope(System.Func<string> name) { }
        public AssertionScope(string name) { }
        public FluentAssertions.Formatting.FormattingOptions FormattingOptions { get; }
        public System.Func<string> Name { get; }
        public static FluentAssertions.Execution.AssertionScope Current { get; }
        public void AddPreFormattedFailure(string formattedFailureMessage) { }
        public void AppendTracing(string tracingBlock) { }
        public string[] Discard() { }
        public void Dispose() { }
        public bool HasFailures() { }
    }
    public class Continuation
    {
        public FluentAssertions.Execution.AssertionChain Then { get; }
    }
    public class ContinuationOfGiven<TSubject>
    {
        public bool Succeeded { get; }
        public FluentAssertions.Execution.GivenSelector<TSubject> Then { get; }
    }
    public class FailReason
    {
        public FailReason(string message, params object[] args) { }
        public object[] Args { get; }
        public string Message { get; }
    }
    public class GivenSelector<T>
    {
        public bool Succeeded { get; }
        public FluentAssertions.Execution.ContinuationOfGiven<T> FailWith(string message) { }
        public FluentAssertions.Execution.ContinuationOfGiven<T> FailWith(string message, params System.Func<T, object>[] args) { }
        public FluentAssertions.Execution.ContinuationOfGiven<T> FailWith(string message, params object[] args) { }
        public FluentAssertions.Execution.GivenSelector<T> ForCondition(System.Func<T, bool> predicate) { }
        public FluentAssertions.Execution.GivenSelector<TOut> Given<TOut>(System.Func<T, TOut> selector) { }
    }
    public interface IAssertionStrategy
    {
        System.Collections.Generic.IEnumerable<string> FailureMessages { get; }
        System.Collections.Generic.IEnumerable<string> DiscardFailures();
        void HandleFailure(string message);
        void ThrowIfAny(System.Collections.Generic.IDictionary<string, object> context);
    }
    public interface ICloneable2
    {
        object Clone();
    }
    public interface ITestFramework
    {
        bool IsAvailable { get; }
        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        void Throw(string message);
    }
    public class Reason
    {
        public Reason(string formattedMessage, object[] arguments) { }
        public object[] Arguments { get; set; }
        public string FormattedMessage { get; set; }
    }
}
namespace FluentAssertions.Extensibility
{
    [System.AttributeUsage(System.AttributeTargets.Assembly, AllowMultiple=true)]
    public sealed class AssertionEngineInitializerAttribute : System.Attribute
    {
        public AssertionEngineInitializerAttribute(System.Type type, string methodName) { }
    }
}
namespace FluentAssertions.Extensions
{
    public static class FluentDateTimeExtensions
    {
        public static System.DateTime AddMicroseconds(this System.DateTime self, long microseconds) { }
        public static System.DateTimeOffset AddMicroseconds(this System.DateTimeOffset self, long microseconds) { }
        public static System.DateTime AddNanoseconds(this System.DateTime self, long nanoseconds) { }
        public static System.DateTimeOffset AddNanoseconds(this System.DateTimeOffset self, long nanoseconds) { }
        public static System.DateTime After(this System.TimeSpan timeDifference, System.DateTime sourceDateTime) { }
        public static System.DateTime April(this int day, int year) { }
        public static System.DateTime AsLocal(this System.DateTime dateTime) { }
        public static System.DateTime AsUtc(this System.DateTime dateTime) { }
        public static System.DateTime At(this System.DateTime date, System.TimeSpan time) { }
        public static System.DateTime At(this System.DateTime date, int hours, int minutes, int seconds = 0, int milliseconds = 0, int microseconds = 0, int nanoseconds = 0) { }
        public static System.DateTimeOffset At(this System.DateTimeOffset date, int hours, int minutes, int seconds = 0, int milliseconds = 0, int microseconds = 0, int nanoseconds = 0) { }
        public static System.DateTime August(this int day, int year) { }
        public static System.DateTime Before(this System.TimeSpan timeDifference, System.DateTime sourceDateTime) { }
        public static System.DateTime December(this int day, int year) { }
        public static System.DateTime February(this int day, int year) { }
        public static System.DateTime January(this int day, int year) { }
        public static System.DateTime July(this int day, int year) { }
        public static System.DateTime June(this int day, int year) { }
        public static System.DateTime March(this int day, int year) { }
        public static System.DateTime May(this int day, int year) { }
        public static int Microsecond(this System.DateTime self) { }
        public static int Microsecond(this System.DateTimeOffset self) { }
        public static int Nanosecond(this System.DateTime self) { }
        public static int Nanosecond(this System.DateTimeOffset self) { }
        public static System.DateTime November(this int day, int year) { }
        public static System.DateTime October(this int day, int year) { }
        public static System.DateTime September(this int day, int year) { }
        public static System.DateTimeOffset WithOffset(this System.DateTime self, System.TimeSpan offset) { }
    }
    public static class FluentTimeSpanExtensions
    {
        public const long TicksPerMicrosecond = 10;
        public const double TicksPerNanosecond = 0.01D;
        public static System.TimeSpan And(this System.TimeSpan sourceTime, System.TimeSpan offset) { }
        public static System.TimeSpan Days(this double days) { }
        public static System.TimeSpan Days(this int days) { }
        public static System.TimeSpan Days(this int days, System.TimeSpan offset) { }
        public static System.TimeSpan Hours(this double hours) { }
        public static System.TimeSpan Hours(this int hours) { }
        public static System.TimeSpan Hours(this int hours, System.TimeSpan offset) { }
        public static int Microseconds(this System.TimeSpan self) { }
        public static System.TimeSpan Microseconds(this int microseconds) { }
        public static System.TimeSpan Microseconds(this long microseconds) { }
        public static System.TimeSpan Milliseconds(this double milliseconds) { }
        public static System.TimeSpan Milliseconds(this int milliseconds) { }
        public static System.TimeSpan Minutes(this double minutes) { }
        public static System.TimeSpan Minutes(this int minutes) { }
        public static System.TimeSpan Minutes(this int minutes, System.TimeSpan offset) { }
        public static int Nanoseconds(this System.TimeSpan self) { }
        public static System.TimeSpan Nanoseconds(this int nanoseconds) { }
        public static System.TimeSpan Nanoseconds(this long nanoseconds) { }
        public static System.TimeSpan Seconds(this double seconds) { }
        public static System.TimeSpan Seconds(this int seconds) { }
        public static System.TimeSpan Seconds(this int seconds, System.TimeSpan offset) { }
        public static System.TimeSpan Ticks(this int ticks) { }
        public static System.TimeSpan Ticks(this long ticks) { }
        public static double TotalMicroseconds(this System.TimeSpan self) { }
        public static double TotalNanoseconds(this System.TimeSpan self) { }
    }
    public static class OccurrenceConstraintExtensions
    {
        public static FluentAssertions.OccurrenceConstraint TimesExactly(this int times) { }
        public static FluentAssertions.OccurrenceConstraint TimesOrLess(this int times) { }
        public static FluentAssertions.OccurrenceConstraint TimesOrMore(this int times) { }
    }
}
namespace FluentAssertions.Formatting
{
    public class AggregateExceptionValueFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public AggregateExceptionValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
    public class AttributeBasedFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public AttributeBasedFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
    public class ByteValueFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public ByteValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
    public class DateTimeOffsetValueFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public DateTimeOffsetValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
    public class DecimalValueFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public DecimalValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
    public class DefaultValueFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public DefaultValueFormatter() { }
        public virtual bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
        protected virtual System.Reflection.MemberInfo[] GetMembers(System.Type type) { }
        protected virtual string TypeDisplayName(System.Type type) { }
    }
    public class DictionaryValueFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public DictionaryValueFormatter() { }
        protected virtual int MaxItems { get; }
        public virtual bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
    public class DoubleValueFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public DoubleValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
    public class EnumValueFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public EnumValueFormatter() { }
        public virtual bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
    public class EnumerableValueFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public EnumerableValueFormatter() { }
        protected virtual int MaxItems { get; }
        public virtual bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
    public class ExceptionValueFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public ExceptionValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
    public class ExpressionValueFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public ExpressionValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
    public delegate void FormatChild(string childPath, object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph);
    public class FormattedObjectGraph
    {
        public FormattedObjectGraph(int maxLines) { }
        public int LineCount { get; }
        public static int SpacesPerIndentation { get; }
        public void AddFragment(string fragment) { }
        public void AddFragmentOnNewLine(string fragment) { }
        public void AddLine(string content) { }
        public void AddLineOrFragment(string fragment) { }
        public override string ToString() { }
        public System.IDisposable WithIndentation() { }
    }
    public static class Formatter
    {
        public static System.Collections.Generic.IEnumerable<FluentAssertions.Formatting.IValueFormatter> Formatters { get; }
        public static void AddFormatter(FluentAssertions.Formatting.IValueFormatter formatter) { }
        public static void RemoveFormatter(FluentAssertions.Formatting.IValueFormatter formatter) { }
        public static string ToString(object value, FluentAssertions.Formatting.FormattingOptions options = null) { }
    }
    public class FormattingContext
    {
        public FormattingContext() { }
        public bool UseLineBreaks { get; set; }
    }
    public class FormattingOptions
    {
        public FormattingOptions() { }
        public int MaxDepth { get; set; }
        public int MaxLines { get; set; }
        public bool UseLineBreaks { get; set; }
        public void AddFormatter(FluentAssertions.Formatting.IValueFormatter formatter) { }
        public void RemoveFormatter(FluentAssertions.Formatting.IValueFormatter formatter) { }
    }
    public class GuidValueFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public GuidValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
    public interface IValueFormatter
    {
        bool CanHandle(object value);
        void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild);
    }
    public class Int16ValueFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public Int16ValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
    public class Int32ValueFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public Int32ValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
    public class Int64ValueFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public Int64ValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
    public class MaxLinesExceededException : System.Exception
    {
        public MaxLinesExceededException() { }
    }
    public class MethodInfoFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public MethodInfoFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
    public class MultidimensionalArrayFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public MultidimensionalArrayFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
    public class NullValueFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public NullValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
    public class PredicateLambdaExpressionValueFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public PredicateLambdaExpressionValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
    public class PropertyInfoFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public PropertyInfoFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
    public class SByteValueFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public SByteValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
    public class SingleValueFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public SingleValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
    public class StringValueFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public StringValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
    public class TaskFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public TaskFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
    public class TimeSpanValueFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public TimeSpanValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
    public class UInt16ValueFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public UInt16ValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
    public class UInt32ValueFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public UInt32ValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
    public class UInt64ValueFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public UInt64ValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Method)]
    public class ValueFormatterAttribute : System.Attribute
    {
        public ValueFormatterAttribute() { }
    }
    public class XAttributeValueFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public XAttributeValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
    public class XDocumentValueFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public XDocumentValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
    public class XElementValueFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public XElementValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
    public class XmlReaderValueFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public XmlReaderValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
}
namespace FluentAssertions.Numeric
{
    public class ComparableTypeAssertions<T> : FluentAssertions.Numeric.ComparableTypeAssertions<T, FluentAssertions.Numeric.ComparableTypeAssertions<T>>
    {
        public ComparableTypeAssertions(System.IComparable<T> value, FluentAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class ComparableTypeAssertions<T, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<System.IComparable<T>, TAssertions>
        where TAssertions : FluentAssertions.Numeric.ComparableTypeAssertions<T, TAssertions>
    {
        public ComparableTypeAssertions(System.IComparable<T> value, FluentAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public FluentAssertions.AndConstraint<TAssertions> Be(T expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeGreaterThan(T expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeGreaterThanOrEqualTo(T expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeInRange(T minimumValue, T maximumValue, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeLessThan(T expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeLessThanOrEqualTo(T expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params T[] validValues) { }
        public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<T> validValues, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeRankedEquallyTo(T expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBe(T unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeInRange(T minimumValue, T maximumValue, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeRankedEquallyTo(T unexpected, string because = "", params object[] becauseArgs) { }
    }
    public class NullableNumericAssertions<T> : FluentAssertions.Numeric.NullableNumericAssertions<T, FluentAssertions.Numeric.NullableNumericAssertions<T>>
        where T :  struct, System.IComparable<T>
    {
        public NullableNumericAssertions(T? value, FluentAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class NullableNumericAssertions<T, TAssertions> : FluentAssertions.Numeric.NumericAssertionsBase<T, T?, TAssertions>
        where T :  struct, System.IComparable<T>
        where TAssertions : FluentAssertions.Numeric.NullableNumericAssertions<T, TAssertions>
    {
        public NullableNumericAssertions(T? value, FluentAssertions.Execution.AssertionChain assertionChain) { }
        public override T? Subject { get; }
        public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveValue(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> Match(System.Linq.Expressions.Expression<System.Func<T?, bool>> predicate, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotHaveValue(string because = "", params object[] becauseArgs) { }
    }
    public abstract class NumericAssertionsBase<T, TSubject, TAssertions>
        where T :  struct, System.IComparable<T>
        where TAssertions : FluentAssertions.Numeric.NumericAssertionsBase<T, TSubject, TAssertions>
    {
        protected NumericAssertionsBase(FluentAssertions.Execution.AssertionChain assertionChain) { }
        public FluentAssertions.Execution.AssertionChain CurrentAssertionChain { get; }
        public abstract TSubject Subject { get; }
        public FluentAssertions.AndConstraint<TAssertions> Be(T expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> Be(T? expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeGreaterThan(T expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeGreaterThanOrEqualTo(T expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeInRange(T minimumValue, T maximumValue, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeLessThan(T expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeLessThanOrEqualTo(T expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeNegative(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeOfType(System.Type expectedType, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params T[] validValues) { }
        public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<T> validValues, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BePositive(string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public FluentAssertions.AndConstraint<TAssertions> Match(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBe(T unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBe(T? unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeInRange(T minimumValue, T maximumValue, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeOfType(System.Type unexpectedType, string because = "", params object[] becauseArgs) { }
    }
    public class NumericAssertions<T> : FluentAssertions.Numeric.NumericAssertions<T, FluentAssertions.Numeric.NumericAssertions<T>>
        where T :  struct, System.IComparable<T>
    {
        public NumericAssertions(T value, FluentAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class NumericAssertions<T, TAssertions> : FluentAssertions.Numeric.NumericAssertionsBase<T, T, TAssertions>
        where T :  struct, System.IComparable<T>
        where TAssertions : FluentAssertions.Numeric.NumericAssertions<T, TAssertions>
    {
        public NumericAssertions(T value, FluentAssertions.Execution.AssertionChain assertionChain) { }
        public override T Subject { get; }
    }
}
namespace FluentAssertions.Primitives
{
    public class BooleanAssertions : FluentAssertions.Primitives.BooleanAssertions<FluentAssertions.Primitives.BooleanAssertions>
    {
        public BooleanAssertions(bool? value, FluentAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class BooleanAssertions<TAssertions>
        where TAssertions : FluentAssertions.Primitives.BooleanAssertions<TAssertions>
    {
        public BooleanAssertions(bool? value, FluentAssertions.Execution.AssertionChain assertionChain) { }
        public bool? Subject { get; }
        public FluentAssertions.AndConstraint<TAssertions> Be(bool expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeFalse(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeTrue(string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public FluentAssertions.AndConstraint<TAssertions> Imply(bool consequent, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBe(bool unexpected, string because = "", params object[] becauseArgs) { }
    }
    public class DateTimeAssertions : FluentAssertions.Primitives.DateTimeAssertions<FluentAssertions.Primitives.DateTimeAssertions>
    {
        public DateTimeAssertions(System.DateTime? value, FluentAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class DateTimeAssertions<TAssertions>
        where TAssertions : FluentAssertions.Primitives.DateTimeAssertions<TAssertions>
    {
        public DateTimeAssertions(System.DateTime? value, FluentAssertions.Execution.AssertionChain assertionChain) { }
        public System.DateTime? Subject { get; }
        public FluentAssertions.AndConstraint<TAssertions> Be(System.DateTime expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> Be(System.DateTime? expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeAfter(System.DateTime expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.Primitives.DateTimeRangeAssertions<TAssertions> BeAtLeast(System.TimeSpan timeSpan) { }
        public FluentAssertions.AndConstraint<TAssertions> BeBefore(System.DateTime expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeCloseTo(System.DateTime nearbyTime, System.TimeSpan precision, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.Primitives.DateTimeRangeAssertions<TAssertions> BeExactly(System.TimeSpan timeSpan) { }
        public FluentAssertions.AndConstraint<TAssertions> BeIn(System.DateTimeKind expectedKind, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.Primitives.DateTimeRangeAssertions<TAssertions> BeLessThan(System.TimeSpan timeSpan) { }
        public FluentAssertions.Primitives.DateTimeRangeAssertions<TAssertions> BeMoreThan(System.TimeSpan timeSpan) { }
        public FluentAssertions.AndConstraint<TAssertions> BeOnOrAfter(System.DateTime expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeOnOrBefore(System.DateTime expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params System.DateTime[] validValues) { }
        public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params System.Nullable<System.DateTime>[] validValues) { }
        public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<System.DateTime> validValues, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<System.DateTime?> validValues, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeSameDateAs(System.DateTime expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.Primitives.DateTimeRangeAssertions<TAssertions> BeWithin(System.TimeSpan timeSpan) { }
        public override bool Equals(object obj) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveDay(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveHour(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveMinute(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveMonth(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveSecond(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveYear(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBe(System.DateTime unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBe(System.DateTime? unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeAfter(System.DateTime unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeBefore(System.DateTime unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeCloseTo(System.DateTime distantTime, System.TimeSpan precision, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeIn(System.DateTimeKind unexpectedKind, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeOnOrAfter(System.DateTime unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeOnOrBefore(System.DateTime unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeSameDateAs(System.DateTime unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotHaveDay(int unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotHaveHour(int unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotHaveMinute(int unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotHaveMonth(int unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotHaveSecond(int unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotHaveYear(int unexpected, string because = "", params object[] becauseArgs) { }
    }
    public class DateTimeOffsetAssertions : FluentAssertions.Primitives.DateTimeOffsetAssertions<FluentAssertions.Primitives.DateTimeOffsetAssertions>
    {
        public DateTimeOffsetAssertions(System.DateTimeOffset? value, FluentAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class DateTimeOffsetAssertions<TAssertions>
        where TAssertions : FluentAssertions.Primitives.DateTimeOffsetAssertions<TAssertions>
    {
        public DateTimeOffsetAssertions(System.DateTimeOffset? value, FluentAssertions.Execution.AssertionChain assertionChain) { }
        public System.DateTimeOffset? Subject { get; }
        public FluentAssertions.AndConstraint<TAssertions> Be(System.DateTimeOffset expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> Be(System.DateTimeOffset? expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeAfter(System.DateTimeOffset expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.Primitives.DateTimeOffsetRangeAssertions<TAssertions> BeAtLeast(System.TimeSpan timeSpan) { }
        public FluentAssertions.AndConstraint<TAssertions> BeBefore(System.DateTimeOffset expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeCloseTo(System.DateTimeOffset nearbyTime, System.TimeSpan precision, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.Primitives.DateTimeOffsetRangeAssertions<TAssertions> BeExactly(System.TimeSpan timeSpan) { }
        public FluentAssertions.AndConstraint<TAssertions> BeExactly(System.DateTimeOffset expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeExactly(System.DateTimeOffset? expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.Primitives.DateTimeOffsetRangeAssertions<TAssertions> BeLessThan(System.TimeSpan timeSpan) { }
        public FluentAssertions.Primitives.DateTimeOffsetRangeAssertions<TAssertions> BeMoreThan(System.TimeSpan timeSpan) { }
        public FluentAssertions.AndConstraint<TAssertions> BeOnOrAfter(System.DateTimeOffset expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeOnOrBefore(System.DateTimeOffset expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params System.DateTimeOffset[] validValues) { }
        public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params System.Nullable<System.DateTimeOffset>[] validValues) { }
        public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<System.DateTimeOffset> validValues, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<System.DateTimeOffset?> validValues, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeSameDateAs(System.DateTimeOffset expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.Primitives.DateTimeOffsetRangeAssertions<TAssertions> BeWithin(System.TimeSpan timeSpan) { }
        public override bool Equals(object obj) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveDay(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveHour(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveMinute(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveMonth(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveOffset(System.TimeSpan expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveSecond(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveYear(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBe(System.DateTimeOffset unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBe(System.DateTimeOffset? unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeAfter(System.DateTimeOffset unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeBefore(System.DateTimeOffset unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeCloseTo(System.DateTimeOffset distantTime, System.TimeSpan precision, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeExactly(System.DateTimeOffset unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeExactly(System.DateTimeOffset? unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeOnOrAfter(System.DateTimeOffset unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeOnOrBefore(System.DateTimeOffset unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeSameDateAs(System.DateTimeOffset unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotHaveDay(int unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotHaveHour(int unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotHaveMinute(int unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotHaveMonth(int unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotHaveOffset(System.TimeSpan unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotHaveSecond(int unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotHaveYear(int unexpected, string because = "", params object[] becauseArgs) { }
    }
    public class DateTimeOffsetRangeAssertions<TAssertions>
        where TAssertions : FluentAssertions.Primitives.DateTimeOffsetAssertions<TAssertions>
    {
        protected DateTimeOffsetRangeAssertions(TAssertions parentAssertions, FluentAssertions.Execution.AssertionChain assertionChain, System.DateTimeOffset? subject, FluentAssertions.Primitives.TimeSpanCondition condition, System.TimeSpan timeSpan) { }
        public FluentAssertions.AndConstraint<TAssertions> After(System.DateTimeOffset target, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> Before(System.DateTimeOffset target, string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
    }
    public class DateTimeRangeAssertions<TAssertions>
        where TAssertions : FluentAssertions.Primitives.DateTimeAssertions<TAssertions>
    {
        protected DateTimeRangeAssertions(TAssertions parentAssertions, FluentAssertions.Execution.AssertionChain assertionChain, System.DateTime? subject, FluentAssertions.Primitives.TimeSpanCondition condition, System.TimeSpan timeSpan) { }
        public FluentAssertions.AndConstraint<TAssertions> After(System.DateTime target, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> Before(System.DateTime target, string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
    }
    public class EnumAssertions<TEnum> : FluentAssertions.Primitives.EnumAssertions<TEnum, FluentAssertions.Primitives.EnumAssertions<TEnum>>
        where TEnum :  struct, System.Enum
    {
        public EnumAssertions(TEnum subject, FluentAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class EnumAssertions<TEnum, TAssertions>
        where TEnum :  struct, System.Enum
        where TAssertions : FluentAssertions.Primitives.EnumAssertions<TEnum, TAssertions>
    {
        public EnumAssertions(TEnum subject, FluentAssertions.Execution.AssertionChain assertionChain) { }
        public TEnum? Subject { get; }
        public FluentAssertions.AndConstraint<TAssertions> Be(TEnum expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> Be(TEnum? expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeDefined(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params TEnum[] validValues) { }
        public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<TEnum> validValues, string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveFlag(TEnum expectedFlag, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveSameNameAs<T>(T expected, string because = "", params object[] becauseArgs)
            where T :  struct, System.Enum { }
        public FluentAssertions.AndConstraint<TAssertions> HaveSameValueAs<T>(T expected, string because = "", params object[] becauseArgs)
            where T :  struct, System.Enum { }
        public FluentAssertions.AndConstraint<TAssertions> HaveValue(decimal expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> Match(System.Linq.Expressions.Expression<System.Func<TEnum?, bool>> predicate, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBe(TEnum unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBe(TEnum? unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeDefined(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotHaveFlag(TEnum unexpectedFlag, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotHaveSameNameAs<T>(T unexpected, string because = "", params object[] becauseArgs)
            where T :  struct, System.Enum { }
        public FluentAssertions.AndConstraint<TAssertions> NotHaveSameValueAs<T>(T unexpected, string because = "", params object[] becauseArgs)
            where T :  struct, System.Enum { }
        public FluentAssertions.AndConstraint<TAssertions> NotHaveValue(decimal unexpected, string because = "", params object[] becauseArgs) { }
    }
    public class GuidAssertions : FluentAssertions.Primitives.GuidAssertions<FluentAssertions.Primitives.GuidAssertions>
    {
        public GuidAssertions(System.Guid? value, FluentAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class GuidAssertions<TAssertions>
        where TAssertions : FluentAssertions.Primitives.GuidAssertions<TAssertions>
    {
        public GuidAssertions(System.Guid? value, FluentAssertions.Execution.AssertionChain assertionChain) { }
        public System.Guid? Subject { get; }
        public FluentAssertions.AndConstraint<TAssertions> Be(System.Guid expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> Be(string expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeEmpty(string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBe(System.Guid unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBe(string unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeEmpty(string because = "", params object[] becauseArgs) { }
    }
    public class NullableBooleanAssertions : FluentAssertions.Primitives.NullableBooleanAssertions<FluentAssertions.Primitives.NullableBooleanAssertions>
    {
        public NullableBooleanAssertions(bool? value, FluentAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class NullableBooleanAssertions<TAssertions> : FluentAssertions.Primitives.BooleanAssertions<TAssertions>
        where TAssertions : FluentAssertions.Primitives.NullableBooleanAssertions<TAssertions>
    {
        public NullableBooleanAssertions(bool? value, FluentAssertions.Execution.AssertionChain assertionChain) { }
        public FluentAssertions.AndConstraint<TAssertions> Be(bool? expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveValue(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBe(bool? unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeFalse(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeTrue(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotHaveValue(string because = "", params object[] becauseArgs) { }
    }
    public class NullableDateTimeAssertions : FluentAssertions.Primitives.NullableDateTimeAssertions<FluentAssertions.Primitives.NullableDateTimeAssertions>
    {
        public NullableDateTimeAssertions(System.DateTime? expected, FluentAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class NullableDateTimeAssertions<TAssertions> : FluentAssertions.Primitives.DateTimeAssertions<TAssertions>
        where TAssertions : FluentAssertions.Primitives.NullableDateTimeAssertions<TAssertions>
    {
        public NullableDateTimeAssertions(System.DateTime? expected, FluentAssertions.Execution.AssertionChain assertionChain) { }
        public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveValue(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotHaveValue(string because = "", params object[] becauseArgs) { }
    }
    public class NullableDateTimeOffsetAssertions : FluentAssertions.Primitives.NullableDateTimeOffsetAssertions<FluentAssertions.Primitives.NullableDateTimeOffsetAssertions>
    {
        public NullableDateTimeOffsetAssertions(System.DateTimeOffset? expected, FluentAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class NullableDateTimeOffsetAssertions<TAssertions> : FluentAssertions.Primitives.DateTimeOffsetAssertions<TAssertions>
        where TAssertions : FluentAssertions.Primitives.NullableDateTimeOffsetAssertions<TAssertions>
    {
        public NullableDateTimeOffsetAssertions(System.DateTimeOffset? expected, FluentAssertions.Execution.AssertionChain assertionChain) { }
        public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveValue(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotHaveValue(string because = "", params object[] becauseArgs) { }
    }
    public class NullableEnumAssertions<TEnum> : FluentAssertions.Primitives.NullableEnumAssertions<TEnum, FluentAssertions.Primitives.NullableEnumAssertions<TEnum>>
        where TEnum :  struct, System.Enum
    {
        public NullableEnumAssertions(TEnum? subject, FluentAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class NullableEnumAssertions<TEnum, TAssertions> : FluentAssertions.Primitives.EnumAssertions<TEnum, TAssertions>
        where TEnum :  struct, System.Enum
        where TAssertions : FluentAssertions.Primitives.NullableEnumAssertions<TEnum, TAssertions>
    {
        public NullableEnumAssertions(TEnum? subject, FluentAssertions.Execution.AssertionChain assertionChain) { }
        public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<TAssertions, TEnum> HaveValue(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<TAssertions, TEnum> NotBeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotHaveValue(string because = "", params object[] becauseArgs) { }
    }
    public class NullableGuidAssertions : FluentAssertions.Primitives.NullableGuidAssertions<FluentAssertions.Primitives.NullableGuidAssertions>
    {
        public NullableGuidAssertions(System.Guid? value, FluentAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class NullableGuidAssertions<TAssertions> : FluentAssertions.Primitives.GuidAssertions<TAssertions>
        where TAssertions : FluentAssertions.Primitives.NullableGuidAssertions<TAssertions>
    {
        public NullableGuidAssertions(System.Guid? value, FluentAssertions.Execution.AssertionChain assertionChain) { }
        public FluentAssertions.AndConstraint<TAssertions> Be(System.Guid? expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveValue(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotHaveValue(string because = "", params object[] becauseArgs) { }
    }
    public class NullableSimpleTimeSpanAssertions : FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions<FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions>
    {
        public NullableSimpleTimeSpanAssertions(System.TimeSpan? value, FluentAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class NullableSimpleTimeSpanAssertions<TAssertions> : FluentAssertions.Primitives.SimpleTimeSpanAssertions<TAssertions>
        where TAssertions : FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions<TAssertions>
    {
        public NullableSimpleTimeSpanAssertions(System.TimeSpan? value, FluentAssertions.Execution.AssertionChain assertionChain) { }
        public FluentAssertions.AndConstraint<TAssertions> Be(System.TimeSpan? expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveValue(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotHaveValue(string because = "", params object[] becauseArgs) { }
    }
    public class ObjectAssertions : FluentAssertions.Primitives.ObjectAssertions<object, FluentAssertions.Primitives.ObjectAssertions>
    {
        public ObjectAssertions(object value, FluentAssertions.Execution.AssertionChain assertionChain) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Primitives.ObjectAssertions> Be<TExpectation>(TExpectation expected, System.Collections.Generic.IEqualityComparer<TExpectation> comparer, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Primitives.ObjectAssertions> BeOneOf<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> validValues, System.Collections.Generic.IEqualityComparer<TExpectation> comparer, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Primitives.ObjectAssertions> NotBe<TExpectation>(TExpectation unexpected, System.Collections.Generic.IEqualityComparer<TExpectation> comparer, string because = "", params object[] becauseArgs) { }
    }
    public class ObjectAssertions<TSubject, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>
        where TAssertions : FluentAssertions.Primitives.ObjectAssertions<TSubject, TAssertions>
    {
        public ObjectAssertions(TSubject value, FluentAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public FluentAssertions.AndConstraint<TAssertions> Be(TSubject expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> Be(TSubject expected, System.Collections.Generic.IEqualityComparer<TSubject> comparer, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params TSubject[] validValues) { }
        public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<TSubject> validValues, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<TSubject> validValues, System.Collections.Generic.IEqualityComparer<TSubject> comparer, string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBe(TSubject unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBe(TSubject unexpected, System.Collections.Generic.IEqualityComparer<TSubject> comparer, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeEquivalentTo<TExpectation>(TExpectation unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeEquivalentTo<TExpectation>(TExpectation unexpected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = "", params object[] becauseArgs) { }
    }
    public abstract class ReferenceTypeAssertions<TSubject, TAssertions>
        where TAssertions : FluentAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>
    {
        protected ReferenceTypeAssertions(TSubject subject, FluentAssertions.Execution.AssertionChain assertionChain) { }
        public FluentAssertions.Execution.AssertionChain CurrentAssertionChain { get; }
        protected abstract string Identifier { get; }
        public TSubject Subject { get; }
        public FluentAssertions.AndConstraint<TAssertions> BeAssignableTo(System.Type type, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<TAssertions, T> BeAssignableTo<T>(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeOfType(System.Type expectedType, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<TAssertions, T> BeOfType<T>(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeSameAs(TSubject expected, string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public FluentAssertions.AndConstraint<TAssertions> Match(System.Linq.Expressions.Expression<System.Func<TSubject, bool>> predicate, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> Match<T>(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, string because = "", params object[] becauseArgs)
            where T : TSubject { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeAssignableTo(System.Type type, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeAssignableTo<T>(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeOfType(System.Type unexpectedType, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeOfType<T>(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeSameAs(TSubject unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> Satisfy<T>(System.Action<T> assertion)
            where T : TSubject { }
    }
    public class SimpleTimeSpanAssertions : FluentAssertions.Primitives.SimpleTimeSpanAssertions<FluentAssertions.Primitives.SimpleTimeSpanAssertions>
    {
        public SimpleTimeSpanAssertions(System.TimeSpan? value, FluentAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class SimpleTimeSpanAssertions<TAssertions>
        where TAssertions : FluentAssertions.Primitives.SimpleTimeSpanAssertions<TAssertions>
    {
        public SimpleTimeSpanAssertions(System.TimeSpan? value, FluentAssertions.Execution.AssertionChain assertionChain) { }
        public System.TimeSpan? Subject { get; }
        public FluentAssertions.AndConstraint<TAssertions> Be(System.TimeSpan expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeCloseTo(System.TimeSpan nearbyTime, System.TimeSpan precision, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeGreaterThan(System.TimeSpan expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeGreaterThanOrEqualTo(System.TimeSpan expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeLessThan(System.TimeSpan expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeLessThanOrEqualTo(System.TimeSpan expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeNegative(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BePositive(string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBe(System.TimeSpan unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeCloseTo(System.TimeSpan distantTime, System.TimeSpan precision, string because = "", params object[] becauseArgs) { }
    }
    public class StringAssertions : FluentAssertions.Primitives.StringAssertions<FluentAssertions.Primitives.StringAssertions>
    {
        public StringAssertions(string value, FluentAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class StringAssertions<TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<string, TAssertions>
        where TAssertions : FluentAssertions.Primitives.StringAssertions<TAssertions>
    {
        public StringAssertions(string value, FluentAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public FluentAssertions.AndConstraint<TAssertions> Be(string expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeEmpty(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo(string expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo(string expected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeLowerCased(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeNullOrEmpty(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeNullOrWhiteSpace(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params string[] validValues) { }
        public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<string> validValues, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeUpperCased(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> Contain(string expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> Contain(string expected, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> ContainAll(params string[] values) { }
        public FluentAssertions.AndConstraint<TAssertions> ContainAll(System.Collections.Generic.IEnumerable<string> values, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> ContainAny(params string[] values) { }
        public FluentAssertions.AndConstraint<TAssertions> ContainAny(System.Collections.Generic.IEnumerable<string> values, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> ContainEquivalentOf(string expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> ContainEquivalentOf(string expected, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> ContainEquivalentOf(string expected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> ContainEquivalentOf(string expected, FluentAssertions.OccurrenceConstraint occurrenceConstraint, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> EndWith(string expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> EndWithEquivalentOf(string expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> EndWithEquivalentOf(string expected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveLength(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> Match(string wildcardPattern, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> MatchEquivalentOf(string wildcardPattern, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> MatchEquivalentOf(string wildcardPattern, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> MatchRegex(string regularExpression, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> MatchRegex(System.Text.RegularExpressions.Regex regularExpression, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> MatchRegex(string regularExpression, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> MatchRegex(System.Text.RegularExpressions.Regex regularExpression, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBe(string unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeEmpty(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeEquivalentTo(string unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeEquivalentTo(string unexpected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeLowerCased(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeNullOrEmpty(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeNullOrWhiteSpace(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeUpperCased(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotContain(string unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotContainAll(params string[] values) { }
        public FluentAssertions.AndConstraint<TAssertions> NotContainAll(System.Collections.Generic.IEnumerable<string> values, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotContainAny(params string[] values) { }
        public FluentAssertions.AndConstraint<TAssertions> NotContainAny(System.Collections.Generic.IEnumerable<string> values, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotContainEquivalentOf(string unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotContainEquivalentOf(string unexpected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotEndWith(string unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotEndWithEquivalentOf(string unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotEndWithEquivalentOf(string unexpected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotMatch(string wildcardPattern, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotMatchEquivalentOf(string wildcardPattern, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotMatchEquivalentOf(string wildcardPattern, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotMatchRegex(string regularExpression, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotMatchRegex(System.Text.RegularExpressions.Regex regularExpression, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotStartWith(string unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotStartWithEquivalentOf(string unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotStartWithEquivalentOf(string unexpected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> StartWith(string expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> StartWithEquivalentOf(string expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> StartWithEquivalentOf(string expected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = "", params object[] becauseArgs) { }
    }
    public enum TimeSpanCondition
    {
        MoreThan = 0,
        AtLeast = 1,
        Exactly = 2,
        Within = 3,
        LessThan = 4,
    }
}
namespace FluentAssertions.Specialized
{
    public class ActionAssertions : FluentAssertions.Specialized.DelegateAssertions<System.Action, FluentAssertions.Specialized.ActionAssertions>
    {
        public ActionAssertions(System.Action subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain) { }
        public ActionAssertions(System.Action subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain, FluentAssertions.Common.IClock clock) { }
        protected override string Identifier { get; }
        protected override void InvokeSubject() { }
        public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ActionAssertions> NotThrow(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ActionAssertions> NotThrowAfter(System.TimeSpan waitTime, System.TimeSpan pollInterval, string because = "", params object[] becauseArgs) { }
    }
    public class AsyncFunctionAssertions<TTask, TAssertions> : FluentAssertions.Specialized.DelegateAssertionsBase<System.Func<TTask>, TAssertions>
        where TTask : System.Threading.Tasks.Task
        where TAssertions : FluentAssertions.Specialized.AsyncFunctionAssertions<TTask, TAssertions>
    {
        protected AsyncFunctionAssertions(System.Func<TTask> subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain, FluentAssertions.Common.IClock clock) { }
        protected override string Identifier { get; }
        public System.Threading.Tasks.Task<FluentAssertions.AndConstraint<TAssertions>> NotCompleteWithinAsync(System.TimeSpan timeSpan, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertions.AndConstraint<TAssertions>> NotThrowAsync<TException>(string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
        public System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<System.Exception>> ThrowAsync(string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> ThrowAsync<TException>(string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
        public System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> ThrowExactlyAsync<TException>(string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
        public System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<System.Exception>> ThrowWithinAsync(System.TimeSpan timeSpan, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> ThrowWithinAsync<TException>(System.TimeSpan timeSpan, string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
    }
    public abstract class DelegateAssertionsBase<TDelegate, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<TDelegate, FluentAssertions.Specialized.DelegateAssertionsBase<TDelegate, TAssertions>>
        where TDelegate : System.Delegate
        where TAssertions : FluentAssertions.Specialized.DelegateAssertionsBase<TDelegate, TAssertions>
    {
        protected FluentAssertions.AndConstraint<TAssertions> NotThrowInternal(System.Exception exception, string because, object[] becauseArgs) { }
        protected FluentAssertions.AndConstraint<TAssertions> NotThrowInternal<TException>(System.Exception exception, string because, object[] becauseArgs)
            where TException : System.Exception { }
        protected FluentAssertions.Specialized.ExceptionAssertions<TException> ThrowInternal<TException>(System.Exception exception, string because, object[] becauseArgs)
            where TException : System.Exception { }
    }
    public abstract class DelegateAssertions<TDelegate, TAssertions> : FluentAssertions.Specialized.DelegateAssertionsBase<TDelegate, TAssertions>
        where TDelegate : System.Delegate
        where TAssertions : FluentAssertions.Specialized.DelegateAssertions<TDelegate, TAssertions>
    {
        protected DelegateAssertions(TDelegate @delegate, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain) { }
        protected abstract void InvokeSubject();
        public FluentAssertions.AndConstraint<TAssertions> NotThrow<TException>(string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
        public FluentAssertions.Specialized.ExceptionAssertions<System.Exception> Throw(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.Specialized.ExceptionAssertions<TException> Throw<TException>(string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
        public FluentAssertions.Specialized.ExceptionAssertions<TException> ThrowExactly<TException>(string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
    }
    public class ExceptionAssertions<TException> : FluentAssertions.Primitives.ReferenceTypeAssertions<System.Collections.Generic.IEnumerable<TException>, FluentAssertions.Specialized.ExceptionAssertions<TException>>
        where TException : System.Exception
    {
        public ExceptionAssertions(System.Collections.Generic.IEnumerable<TException> exceptions, FluentAssertions.Execution.AssertionChain assertionChain) { }
        public TException And { get; }
        protected override string Identifier { get; }
        public TException Which { get; }
        public FluentAssertions.Specialized.ExceptionAssertions<TException> Where(System.Linq.Expressions.Expression<System.Func<TException, bool>> exceptionExpression, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.Specialized.ExceptionAssertions<System.Exception> WithInnerException(System.Type innerException, string because = "", params object[] becauseArgs) { }
        public virtual FluentAssertions.Specialized.ExceptionAssertions<TInnerException> WithInnerException<TInnerException>(string because = "", params object[] becauseArgs)
            where TInnerException : System.Exception { }
        public FluentAssertions.Specialized.ExceptionAssertions<System.Exception> WithInnerExceptionExactly(System.Type innerException, string because = "", params object[] becauseArgs) { }
        public virtual FluentAssertions.Specialized.ExceptionAssertions<TInnerException> WithInnerExceptionExactly<TInnerException>(string because = "", params object[] becauseArgs)
            where TInnerException : System.Exception { }
        public virtual FluentAssertions.Specialized.ExceptionAssertions<TException> WithMessage(string expectedWildcardPattern, string because = "", params object[] becauseArgs) { }
    }
    public class ExecutionTime
    {
        public ExecutionTime(System.Action action, FluentAssertions.Common.StartTimer createTimer) { }
        public ExecutionTime(System.Func<System.Threading.Tasks.Task> action, FluentAssertions.Common.StartTimer createTimer) { }
        protected ExecutionTime(System.Action action, string actionDescription, FluentAssertions.Common.StartTimer createTimer) { }
        protected ExecutionTime(System.Func<System.Threading.Tasks.Task> action, string actionDescription, FluentAssertions.Common.StartTimer createTimer) { }
    }
    public class ExecutionTimeAssertions
    {
        public ExecutionTimeAssertions(FluentAssertions.Specialized.ExecutionTime executionTime, FluentAssertions.Execution.AssertionChain assertionChain) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ExecutionTimeAssertions> BeCloseTo(System.TimeSpan expectedDuration, System.TimeSpan precision, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ExecutionTimeAssertions> BeGreaterThan(System.TimeSpan minDuration, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ExecutionTimeAssertions> BeGreaterThanOrEqualTo(System.TimeSpan minDuration, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ExecutionTimeAssertions> BeLessThan(System.TimeSpan maxDuration, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ExecutionTimeAssertions> BeLessThanOrEqualTo(System.TimeSpan maxDuration, string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
    }
    public class FunctionAssertions<T> : FluentAssertions.Specialized.DelegateAssertions<System.Func<T>, FluentAssertions.Specialized.FunctionAssertions<T>>
    {
        public FunctionAssertions(System.Func<T> subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain) { }
        public FunctionAssertions(System.Func<T> subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain, FluentAssertions.Common.IClock clock) { }
        protected override string Identifier { get; }
        protected override void InvokeSubject() { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.FunctionAssertions<T>, T> NotThrow(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.FunctionAssertions<T>, T> NotThrowAfter(System.TimeSpan waitTime, System.TimeSpan pollInterval, string because = "", params object[] becauseArgs) { }
    }
    public class GenericAsyncFunctionAssertions<TResult> : FluentAssertions.Specialized.AsyncFunctionAssertions<System.Threading.Tasks.Task<TResult>, FluentAssertions.Specialized.GenericAsyncFunctionAssertions<TResult>>
    {
        public GenericAsyncFunctionAssertions(System.Func<System.Threading.Tasks.Task<TResult>> subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain) { }
        public GenericAsyncFunctionAssertions(System.Func<System.Threading.Tasks.Task<TResult>> subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain, FluentAssertions.Common.IClock clock) { }
        public System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.GenericAsyncFunctionAssertions<TResult>, TResult>> CompleteWithinAsync(System.TimeSpan timeSpan, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.GenericAsyncFunctionAssertions<TResult>, TResult>> NotThrowAfterAsync(System.TimeSpan waitTime, System.TimeSpan pollInterval, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.GenericAsyncFunctionAssertions<TResult>, TResult>> NotThrowAsync(string because = "", params object[] becauseArgs) { }
    }
    public interface IExtractExceptions
    {
        System.Collections.Generic.IEnumerable<T> OfType<T>(System.Exception actualException)
            where T : System.Exception;
    }
    public class MemberExecutionTime<T> : FluentAssertions.Specialized.ExecutionTime
    {
        public MemberExecutionTime(T subject, System.Linq.Expressions.Expression<System.Action<T>> action, FluentAssertions.Common.StartTimer createTimer) { }
    }
    public class NonGenericAsyncFunctionAssertions : FluentAssertions.Specialized.AsyncFunctionAssertions<System.Threading.Tasks.Task, FluentAssertions.Specialized.NonGenericAsyncFunctionAssertions>
    {
        public NonGenericAsyncFunctionAssertions(System.Func<System.Threading.Tasks.Task> subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain) { }
        public NonGenericAsyncFunctionAssertions(System.Func<System.Threading.Tasks.Task> subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain, FluentAssertions.Common.IClock clock) { }
        public System.Threading.Tasks.Task<FluentAssertions.AndConstraint<FluentAssertions.Specialized.NonGenericAsyncFunctionAssertions>> CompleteWithinAsync(System.TimeSpan timeSpan, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertions.AndConstraint<FluentAssertions.Specialized.NonGenericAsyncFunctionAssertions>> NotThrowAfterAsync(System.TimeSpan waitTime, System.TimeSpan pollInterval, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertions.AndConstraint<FluentAssertions.Specialized.NonGenericAsyncFunctionAssertions>> NotThrowAsync(string because = "", params object[] becauseArgs) { }
    }
    public class TaskCompletionSourceAssertionsBase
    {
        protected TaskCompletionSourceAssertionsBase(FluentAssertions.Common.IClock clock) { }
        public override bool Equals(object obj) { }
    }
    public class TaskCompletionSourceAssertions<T> : FluentAssertions.Specialized.TaskCompletionSourceAssertionsBase
    {
        public TaskCompletionSourceAssertions(System.Threading.Tasks.TaskCompletionSource<T> tcs, FluentAssertions.Execution.AssertionChain assertionChain) { }
        public TaskCompletionSourceAssertions(System.Threading.Tasks.TaskCompletionSource<T> tcs, FluentAssertions.Execution.AssertionChain assertionChain, FluentAssertions.Common.IClock clock) { }
        public System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.TaskCompletionSourceAssertions<T>, T>> CompleteWithinAsync(System.TimeSpan timeSpan, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertions.AndConstraint<FluentAssertions.Specialized.TaskCompletionSourceAssertions<T>>> NotCompleteWithinAsync(System.TimeSpan timeSpan, string because = "", params object[] becauseArgs) { }
    }
}
namespace FluentAssertions.Streams
{
    public class BufferedStreamAssertions : FluentAssertions.Streams.BufferedStreamAssertions<FluentAssertions.Streams.BufferedStreamAssertions>
    {
        public BufferedStreamAssertions(System.IO.BufferedStream stream, FluentAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class BufferedStreamAssertions<TAssertions> : FluentAssertions.Streams.StreamAssertions<System.IO.BufferedStream, TAssertions>
        where TAssertions : FluentAssertions.Streams.BufferedStreamAssertions<TAssertions>
    {
        public BufferedStreamAssertions(System.IO.BufferedStream stream, FluentAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
    }
    public class StreamAssertions : FluentAssertions.Streams.StreamAssertions<System.IO.Stream, FluentAssertions.Streams.StreamAssertions>
    {
        public StreamAssertions(System.IO.Stream stream, FluentAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class StreamAssertions<TSubject, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>
        where TSubject : System.IO.Stream
        where TAssertions : FluentAssertions.Streams.StreamAssertions<TSubject, TAssertions>
    {
        public StreamAssertions(TSubject stream, FluentAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public FluentAssertions.AndConstraint<TAssertions> BeReadOnly(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeReadable(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeSeekable(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeWritable(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> BeWriteOnly(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveLength(long expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> HavePosition(long expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeReadOnly(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeReadable(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeSeekable(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeWritable(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeWriteOnly(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotHaveLength(long unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotHavePosition(long unexpected, string because = "", params object[] becauseArgs) { }
    }
}
namespace FluentAssertions.Types
{
    public static class AllTypes
    {
        public static FluentAssertions.Types.TypeSelector From(System.Reflection.Assembly assembly) { }
    }
    public class AssemblyAssertions : FluentAssertions.Primitives.ReferenceTypeAssertions<System.Reflection.Assembly, FluentAssertions.Types.AssemblyAssertions>
    {
        public AssemblyAssertions(System.Reflection.Assembly assembly, FluentAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.AssemblyAssertions> BeSignedWithPublicKey(string publicKey, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.AssemblyAssertions> BeUnsigned(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.AssemblyAssertions, System.Type> DefineType(string @namespace, string name, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.AssemblyAssertions> NotReference(System.Reflection.Assembly assembly, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.AssemblyAssertions> Reference(System.Reflection.Assembly assembly, string because = "", params object[] becauseArgs) { }
    }
    public class ConstructorInfoAssertions : FluentAssertions.Types.MethodBaseAssertions<System.Reflection.ConstructorInfo, FluentAssertions.Types.ConstructorInfoAssertions>
    {
        public ConstructorInfoAssertions(System.Reflection.ConstructorInfo constructorInfo, FluentAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
    }
    public abstract class MemberInfoAssertions<TSubject, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>
        where TSubject : System.Reflection.MemberInfo
        where TAssertions : FluentAssertions.Types.MemberInfoAssertions<TSubject, TAssertions>
    {
        protected MemberInfoAssertions(TSubject subject, FluentAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.MemberInfoAssertions<TSubject, TAssertions>, TAttribute> BeDecoratedWith<TAttribute>(string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.MemberInfoAssertions<TSubject, TAssertions>, TAttribute> BeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeDecoratedWith<TAttribute>(string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
    }
    public abstract class MethodBaseAssertions<TSubject, TAssertions> : FluentAssertions.Types.MemberInfoAssertions<TSubject, TAssertions>
        where TSubject : System.Reflection.MethodBase
        where TAssertions : FluentAssertions.Types.MethodBaseAssertions<TSubject, TAssertions>
    {
        protected MethodBaseAssertions(TSubject subject, FluentAssertions.Execution.AssertionChain assertionChain) { }
        public FluentAssertions.AndConstraint<TAssertions> HaveAccessModifier(FluentAssertions.Common.CSharpAccessModifier accessModifier, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotHaveAccessModifier(FluentAssertions.Common.CSharpAccessModifier accessModifier, string because = "", params object[] becauseArgs) { }
    }
    public class MethodInfoAssertions : FluentAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertions.Types.MethodInfoAssertions>
    {
        public MethodInfoAssertions(System.Reflection.MethodInfo methodInfo, FluentAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoAssertions> BeAsync(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoAssertions> BeVirtual(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoAssertions> NotBeAsync(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoAssertions> NotBeVirtual(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertions.Types.MethodInfoAssertions>> NotReturn(System.Type returnType, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertions.Types.MethodInfoAssertions>> NotReturn<TReturn>(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertions.Types.MethodInfoAssertions>> NotReturnVoid(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertions.Types.MethodInfoAssertions>> Return(System.Type returnType, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertions.Types.MethodInfoAssertions>> Return<TReturn>(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertions.Types.MethodInfoAssertions>> ReturnVoid(string because = "", params object[] becauseArgs) { }
    }
    public class MethodInfoSelector : System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo>, System.Collections.IEnumerable
    {
        public MethodInfoSelector(System.Collections.Generic.IEnumerable<System.Type> types) { }
        public MethodInfoSelector(System.Type type) { }
        public FluentAssertions.Types.MethodInfoSelector ThatArePublicOrInternal { get; }
        public FluentAssertions.Types.MethodInfoSelector ThatDoNotReturnVoid { get; }
        public FluentAssertions.Types.MethodInfoSelector ThatReturnVoid { get; }
        public System.Collections.Generic.IEnumerator<System.Reflection.MethodInfo> GetEnumerator() { }
        public FluentAssertions.Types.TypeSelector ReturnTypes() { }
        public FluentAssertions.Types.MethodInfoSelector ThatAreAbstract() { }
        public FluentAssertions.Types.MethodInfoSelector ThatAreAsync() { }
        public FluentAssertions.Types.MethodInfoSelector ThatAreDecoratedWith<TAttribute>()
            where TAttribute : System.Attribute { }
        public FluentAssertions.Types.MethodInfoSelector ThatAreDecoratedWithOrInherit<TAttribute>()
            where TAttribute : System.Attribute { }
        public FluentAssertions.Types.MethodInfoSelector ThatAreNotAbstract() { }
        public FluentAssertions.Types.MethodInfoSelector ThatAreNotAsync() { }
        public FluentAssertions.Types.MethodInfoSelector ThatAreNotDecoratedWith<TAttribute>()
            where TAttribute : System.Attribute { }
        public FluentAssertions.Types.MethodInfoSelector ThatAreNotDecoratedWithOrInherit<TAttribute>()
            where TAttribute : System.Attribute { }
        public FluentAssertions.Types.MethodInfoSelector ThatAreNotStatic() { }
        public FluentAssertions.Types.MethodInfoSelector ThatAreNotVirtual() { }
        public FluentAssertions.Types.MethodInfoSelector ThatAreStatic() { }
        public FluentAssertions.Types.MethodInfoSelector ThatAreVirtual() { }
        public FluentAssertions.Types.MethodInfoSelector ThatDoNotReturn<TReturn>() { }
        public FluentAssertions.Types.MethodInfoSelector ThatReturn<TReturn>() { }
        public System.Reflection.MethodInfo[] ToArray() { }
    }
    public class MethodInfoSelectorAssertions
    {
        public MethodInfoSelectorAssertions(FluentAssertions.Execution.AssertionChain assertionChain, params System.Reflection.MethodInfo[] methods) { }
        protected string Context { get; }
        public System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo> SubjectMethods { get; }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoSelectorAssertions> Be(FluentAssertions.Common.CSharpAccessModifier accessModifier, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoSelectorAssertions> BeAsync(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoSelectorAssertions> BeDecoratedWith<TAttribute>(string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoSelectorAssertions> BeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoSelectorAssertions> BeVirtual(string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoSelectorAssertions> NotBe(FluentAssertions.Common.CSharpAccessModifier accessModifier, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoSelectorAssertions> NotBeAsync(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoSelectorAssertions> NotBeDecoratedWith<TAttribute>(string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoSelectorAssertions> NotBeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoSelectorAssertions> NotBeVirtual(string because = "", params object[] becauseArgs) { }
    }
    public class PropertyInfoAssertions : FluentAssertions.Types.MemberInfoAssertions<System.Reflection.PropertyInfo, FluentAssertions.Types.PropertyInfoAssertions>
    {
        public PropertyInfoAssertions(System.Reflection.PropertyInfo propertyInfo, FluentAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> BeReadable(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> BeReadable(FluentAssertions.Common.CSharpAccessModifier accessModifier, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> BeVirtual(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> BeWritable(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> BeWritable(FluentAssertions.Common.CSharpAccessModifier accessModifier, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> NotBeReadable(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> NotBeVirtual(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> NotBeWritable(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> NotReturn(System.Type propertyType, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> NotReturn<TReturn>(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> Return(System.Type propertyType, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> Return<TReturn>(string because = "", params object[] becauseArgs) { }
    }
    public class PropertyInfoSelector : System.Collections.Generic.IEnumerable<System.Reflection.PropertyInfo>, System.Collections.IEnumerable
    {
        public PropertyInfoSelector(System.Collections.Generic.IEnumerable<System.Type> types) { }
        public PropertyInfoSelector(System.Type type) { }
        public FluentAssertions.Types.PropertyInfoSelector ThatAreAbstract { get; }
        public FluentAssertions.Types.PropertyInfoSelector ThatAreNotAbstract { get; }
        public FluentAssertions.Types.PropertyInfoSelector ThatAreNotStatic { get; }
        public FluentAssertions.Types.PropertyInfoSelector ThatAreNotVirtual { get; }
        public FluentAssertions.Types.PropertyInfoSelector ThatArePublicOrInternal { get; }
        public FluentAssertions.Types.PropertyInfoSelector ThatAreStatic { get; }
        public FluentAssertions.Types.PropertyInfoSelector ThatAreVirtual { get; }
        public System.Collections.Generic.IEnumerator<System.Reflection.PropertyInfo> GetEnumerator() { }
        public FluentAssertions.Types.PropertyInfoSelector NotOfType<TReturn>() { }
        public FluentAssertions.Types.PropertyInfoSelector OfType<TReturn>() { }
        public FluentAssertions.Types.TypeSelector ReturnTypes() { }
        public FluentAssertions.Types.PropertyInfoSelector ThatAreDecoratedWith<TAttribute>()
            where TAttribute : System.Attribute { }
        public FluentAssertions.Types.PropertyInfoSelector ThatAreDecoratedWithOrInherit<TAttribute>()
            where TAttribute : System.Attribute { }
        public FluentAssertions.Types.PropertyInfoSelector ThatAreNotDecoratedWith<TAttribute>()
            where TAttribute : System.Attribute { }
        public FluentAssertions.Types.PropertyInfoSelector ThatAreNotDecoratedWithOrInherit<TAttribute>()
            where TAttribute : System.Attribute { }
        public System.Reflection.PropertyInfo[] ToArray() { }
    }
    public class PropertyInfoSelectorAssertions
    {
        public PropertyInfoSelectorAssertions(FluentAssertions.Execution.AssertionChain assertionChain, params System.Reflection.PropertyInfo[] properties) { }
        protected string Context { get; }
        public System.Collections.Generic.IEnumerable<System.Reflection.PropertyInfo> SubjectProperties { get; }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoSelectorAssertions> BeDecoratedWith<TAttribute>(string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoSelectorAssertions> BeVirtual(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoSelectorAssertions> BeWritable(string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoSelectorAssertions> NotBeDecoratedWith<TAttribute>(string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoSelectorAssertions> NotBeVirtual(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoSelectorAssertions> NotBeWritable(string because = "", params object[] becauseArgs) { }
    }
    public class TypeAssertions : FluentAssertions.Primitives.ReferenceTypeAssertions<System.Type, FluentAssertions.Types.TypeAssertions>
    {
        public TypeAssertions(System.Type type, FluentAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> Be(System.Type expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> Be<TExpected>(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeAbstract(string because = "", params object[] becauseArgs) { }
        public new FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeAssignableTo(System.Type type, string because = "", params object[] becauseArgs) { }
        public new FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeAssignableTo<T>(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, TAttribute> BeDecoratedWith<TAttribute>(string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, TAttribute> BeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, TAttribute> BeDecoratedWithOrInherit<TAttribute>(string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, TAttribute> BeDecoratedWithOrInherit<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeDerivedFrom(System.Type baseType, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeDerivedFrom<TBaseClass>(string because = "", params object[] becauseArgs)
            where TBaseClass :  class { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeSealed(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeStatic(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> HaveAccessModifier(FluentAssertions.Common.CSharpAccessModifier accessModifier, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.ConstructorInfo> HaveConstructor(System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.ConstructorInfo> HaveDefaultConstructor(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.MethodInfo> HaveExplicitConversionOperator(System.Type sourceType, System.Type targetType, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.MethodInfo> HaveExplicitConversionOperator<TSource, TTarget>(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> HaveExplicitMethod(System.Type interfaceType, string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> HaveExplicitMethod<TInterface>(string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = "", params object[] becauseArgs)
            where TInterface :  class { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> HaveExplicitProperty(System.Type interfaceType, string name, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> HaveExplicitProperty<TInterface>(string name, string because = "", params object[] becauseArgs)
            where TInterface :  class { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.MethodInfo> HaveImplicitConversionOperator(System.Type sourceType, System.Type targetType, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.MethodInfo> HaveImplicitConversionOperator<TSource, TTarget>(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.PropertyInfo> HaveIndexer(System.Type indexerType, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.MethodInfo> HaveMethod(string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.PropertyInfo> HaveProperty(System.Type propertyType, string name, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.PropertyInfo> HaveProperty<TProperty>(string name, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> Implement(System.Type interfaceType, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> Implement<TInterface>(string because = "", params object[] becauseArgs)
            where TInterface :  class { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBe(System.Type unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBe<TUnexpected>(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeAbstract(string because = "", params object[] becauseArgs) { }
        public new FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeAssignableTo(System.Type type, string because = "", params object[] becauseArgs) { }
        public new FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeAssignableTo<T>(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeDecoratedWith<TAttribute>(string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeDecoratedWithOrInherit<TAttribute>(string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeDecoratedWithOrInherit<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeDerivedFrom(System.Type baseType, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeDerivedFrom<TBaseClass>(string because = "", params object[] becauseArgs)
            where TBaseClass :  class { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeSealed(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeStatic(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveAccessModifier(FluentAssertions.Common.CSharpAccessModifier accessModifier, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.ConstructorInfo> NotHaveConstructor(System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.ConstructorInfo> NotHaveDefaultConstructor(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveExplicitConversionOperator(System.Type sourceType, System.Type targetType, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveExplicitConversionOperator<TSource, TTarget>(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveExplicitMethod(System.Type interfaceType, string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveExplicitMethod<TInterface>(string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = "", params object[] becauseArgs)
            where TInterface :  class { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveExplicitProperty(System.Type interfaceType, string name, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveExplicitProperty<TInterface>(string name, string because = "", params object[] becauseArgs)
            where TInterface :  class { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveImplicitConversionOperator(System.Type sourceType, System.Type targetType, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveImplicitConversionOperator<TSource, TTarget>(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveIndexer(System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveMethod(string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveProperty(string name, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotImplement(System.Type interfaceType, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotImplement<TInterface>(string because = "", params object[] becauseArgs)
            where TInterface :  class { }
    }
    public class TypeSelector : System.Collections.Generic.IEnumerable<System.Type>, System.Collections.IEnumerable
    {
        public TypeSelector(System.Collections.Generic.IEnumerable<System.Type> types) { }
        public TypeSelector(System.Type type) { }
        public System.Collections.Generic.IEnumerator<System.Type> GetEnumerator() { }
        public FluentAssertions.Types.TypeSelector ThatAreAbstract() { }
        public FluentAssertions.Types.TypeSelector ThatAreClasses() { }
        public FluentAssertions.Types.TypeSelector ThatAreDecoratedWith<TAttribute>()
            where TAttribute : System.Attribute { }
        public FluentAssertions.Types.TypeSelector ThatAreDecoratedWithOrInherit<TAttribute>()
            where TAttribute : System.Attribute { }
        public FluentAssertions.Types.TypeSelector ThatAreInNamespace(string @namespace) { }
        public FluentAssertions.Types.TypeSelector ThatAreInterfaces() { }
        public FluentAssertions.Types.TypeSelector ThatAreNotAbstract() { }
        public FluentAssertions.Types.TypeSelector ThatAreNotClasses() { }
        public FluentAssertions.Types.TypeSelector ThatAreNotDecoratedWith<TAttribute>()
            where TAttribute : System.Attribute { }
        public FluentAssertions.Types.TypeSelector ThatAreNotDecoratedWithOrInherit<TAttribute>()
            where TAttribute : System.Attribute { }
        public FluentAssertions.Types.TypeSelector ThatAreNotInNamespace(string @namespace) { }
        public FluentAssertions.Types.TypeSelector ThatAreNotInterfaces() { }
        public FluentAssertions.Types.TypeSelector ThatAreNotSealed() { }
        public FluentAssertions.Types.TypeSelector ThatAreNotStatic() { }
        public FluentAssertions.Types.TypeSelector ThatAreNotUnderNamespace(string @namespace) { }
        public FluentAssertions.Types.TypeSelector ThatAreNotValueTypes() { }
        public FluentAssertions.Types.TypeSelector ThatAreSealed() { }
        public FluentAssertions.Types.TypeSelector ThatAreStatic() { }
        public FluentAssertions.Types.TypeSelector ThatAreUnderNamespace(string @namespace) { }
        public FluentAssertions.Types.TypeSelector ThatAreValueTypes() { }
        public FluentAssertions.Types.TypeSelector ThatDeriveFrom<TBase>() { }
        public FluentAssertions.Types.TypeSelector ThatDoNotDeriveFrom<TBase>() { }
        public FluentAssertions.Types.TypeSelector ThatDoNotImplement<TInterface>() { }
        public FluentAssertions.Types.TypeSelector ThatImplement<TInterface>() { }
        public FluentAssertions.Types.TypeSelector ThatSatisfy(System.Func<System.Type, bool> predicate) { }
        public System.Type[] ToArray() { }
        public FluentAssertions.Types.TypeSelector UnwrapEnumerableTypes() { }
        public FluentAssertions.Types.TypeSelector UnwrapTaskTypes() { }
    }
    public class TypeSelectorAssertions
    {
        public TypeSelectorAssertions(FluentAssertions.Execution.AssertionChain assertionChain, params System.Type[] types) { }
        public System.Collections.Generic.IEnumerable<System.Type> Subject { get; }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> BeDecoratedWith<TAttribute>(string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> BeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> BeDecoratedWithOrInherit<TAttribute>(string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> BeDecoratedWithOrInherit<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> BeInNamespace(string @namespace, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> BeSealed(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> BeUnderNamespace(string @namespace, string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> NotBeDecoratedWith<TAttribute>(string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> NotBeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> NotBeDecoratedWithOrInherit<TAttribute>(string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> NotBeDecoratedWithOrInherit<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> NotBeInNamespace(string @namespace, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> NotBeSealed(string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> NotBeUnderNamespace(string @namespace, string because = "", params object[] becauseArgs) { }
    }
}
namespace FluentAssertions.Xml
{
    public class XAttributeAssertions : FluentAssertions.Primitives.ReferenceTypeAssertions<System.Xml.Linq.XAttribute, FluentAssertions.Xml.XAttributeAssertions>
    {
        public XAttributeAssertions(System.Xml.Linq.XAttribute attribute, FluentAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public FluentAssertions.AndConstraint<FluentAssertions.Xml.XAttributeAssertions> Be(System.Xml.Linq.XAttribute expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Xml.XAttributeAssertions> HaveValue(string expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Xml.XAttributeAssertions> NotBe(System.Xml.Linq.XAttribute unexpected, string because = "", params object[] becauseArgs) { }
    }
    public class XDocumentAssertions : FluentAssertions.Primitives.ReferenceTypeAssertions<System.Xml.Linq.XDocument, FluentAssertions.Xml.XDocumentAssertions>
    {
        public XDocumentAssertions(System.Xml.Linq.XDocument document, FluentAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> Be(System.Xml.Linq.XDocument expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> BeEquivalentTo(System.Xml.Linq.XDocument expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveElement(string expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveElement(System.Xml.Linq.XName expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Collections.Generic.IEnumerable<System.Xml.Linq.XElement>> HaveElement(string expected, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Collections.Generic.IEnumerable<System.Xml.Linq.XElement>> HaveElement(System.Xml.Linq.XName expected, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveElementWithValue(string expectedElement, string expectedValue, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveElementWithValue(System.Xml.Linq.XName expectedElement, string expectedValue, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveRoot(string expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveRoot(System.Xml.Linq.XName expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> NotBe(System.Xml.Linq.XDocument unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> NotBeEquivalentTo(System.Xml.Linq.XDocument unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> NotHaveElement(string unexpectedElement, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> NotHaveElement(System.Xml.Linq.XName unexpectedElement, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> NotHaveElementWithValue(string unexpectedElement, string unexpectedValue, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> NotHaveElementWithValue(System.Xml.Linq.XName unexpectedElement, string unexpectedValue, string because = "", params object[] becauseArgs) { }
    }
    public class XElementAssertions : FluentAssertions.Primitives.ReferenceTypeAssertions<System.Xml.Linq.XElement, FluentAssertions.Xml.XElementAssertions>
    {
        public XElementAssertions(System.Xml.Linq.XElement xElement, FluentAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> Be(System.Xml.Linq.XElement expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> BeEquivalentTo(System.Xml.Linq.XElement expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> HaveAttribute(string expectedName, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> HaveAttribute(System.Xml.Linq.XName expectedName, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> HaveAttributeWithValue(string expectedName, string expectedValue, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> HaveAttributeWithValue(System.Xml.Linq.XName expectedName, string expectedValue, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XElementAssertions, System.Xml.Linq.XElement> HaveElement(string expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XElementAssertions, System.Xml.Linq.XElement> HaveElement(System.Xml.Linq.XName expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XElementAssertions, System.Collections.Generic.IEnumerable<System.Xml.Linq.XElement>> HaveElement(string expected, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XElementAssertions, System.Collections.Generic.IEnumerable<System.Xml.Linq.XElement>> HaveElement(System.Xml.Linq.XName expected, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XElementAssertions, System.Xml.Linq.XElement> HaveElementWithValue(string expectedElement, string expectedValue, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XElementAssertions, System.Xml.Linq.XElement> HaveElementWithValue(System.Xml.Linq.XName expectedElement, string expectedValue, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> HaveValue(string expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotBe(System.Xml.Linq.XElement unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotBeEquivalentTo(System.Xml.Linq.XElement unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveAttribute(string unexpectedName, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveAttribute(System.Xml.Linq.XName unexpectedName, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveAttributeWithValue(string unexpectedName, string unexpectedValue, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveAttributeWithValue(System.Xml.Linq.XName unexpectedName, string unexpectedValue, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveElement(string unexpectedElement, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveElement(System.Xml.Linq.XName unexpectedElement, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveElementWithValue(string unexpectedElement, string unexpectedValue, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveElementWithValue(System.Xml.Linq.XName unexpectedElement, string unexpectedValue, string because = "", params object[] becauseArgs) { }
    }
    public class XmlElementAssertions : FluentAssertions.Xml.XmlNodeAssertions<System.Xml.XmlElement, FluentAssertions.Xml.XmlElementAssertions>
    {
        public XmlElementAssertions(System.Xml.XmlElement xmlElement, FluentAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public FluentAssertions.AndConstraint<FluentAssertions.Xml.XmlElementAssertions> HaveAttribute(string expectedName, string expectedValue, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Xml.XmlElementAssertions> HaveAttributeWithNamespace(string expectedName, string expectedNamespace, string expectedValue, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XmlElementAssertions, System.Xml.XmlElement> HaveElement(string expectedName, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XmlElementAssertions, System.Xml.XmlElement> HaveElementWithNamespace(string expectedName, string expectedNamespace, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<FluentAssertions.Xml.XmlElementAssertions> HaveInnerText(string expected, string because = "", params object[] becauseArgs) { }
    }
    public class XmlNodeAssertions : FluentAssertions.Xml.XmlNodeAssertions<System.Xml.XmlNode, FluentAssertions.Xml.XmlNodeAssertions>
    {
        public XmlNodeAssertions(System.Xml.XmlNode xmlNode, FluentAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class XmlNodeAssertions<TSubject, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>
        where TSubject : System.Xml.XmlNode
        where TAssertions : FluentAssertions.Xml.XmlNodeAssertions<TSubject, TAssertions>
    {
        public XmlNodeAssertions(TSubject xmlNode, FluentAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo(System.Xml.XmlNode expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertions.AndConstraint<TAssertions> NotBeEquivalentTo(System.Xml.XmlNode unexpected, string because = "", params object[] becauseArgs) { }
    }
    public class XmlNodeFormatter : FluentAssertions.Formatting.IValueFormatter
    {
        public XmlNodeFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }
    }
}